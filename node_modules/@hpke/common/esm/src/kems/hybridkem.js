import { EMPTY } from "../consts.js";
import { DeserializeError, InvalidParamError, NotSupportedError, SerializeError, } from "../errors.js";
import { KemId } from "../identifiers.js";
import { LABEL_DKP_PRK, LABEL_SK } from "../interfaces/dhkemPrimitives.js";
import { SUITE_ID_HEADER_KEM } from "../interfaces/kemInterface.js";
import { concat, i2Osp, isCryptoKeyPair } from "../utils/misc.js";
import { XCryptoKey } from "../xCryptoKey.js";
export class Hybridkem {
    constructor(id, a, b, kdf) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: KemId.NotAssigned
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_a", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_b", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = id;
        this._a = a;
        this._b = b;
        this._kdf = kdf;
        const suiteId = new Uint8Array(SUITE_ID_HEADER_KEM);
        suiteId.set(i2Osp(this.id, 2), 3);
        this._kdf.init(suiteId);
    }
    async serializePublicKey(key) {
        try {
            return await this._serializePublicKey(key);
        }
        catch (e) {
            throw new SerializeError(e);
        }
    }
    async deserializePublicKey(key) {
        try {
            return await this._deserializePublicKey(key);
        }
        catch (e) {
            throw new DeserializeError(e);
        }
    }
    async serializePrivateKey(key) {
        try {
            return await this._serializePrivateKey(key);
        }
        catch (e) {
            throw new SerializeError(e);
        }
    }
    async deserializePrivateKey(key) {
        try {
            return await this._deserializePrivateKey(key);
        }
        catch (e) {
            throw new DeserializeError(e);
        }
    }
    async generateKeyPair() {
        const kpA = await this._a.generateKeyPair();
        const kpB = await this._b.generateKeyPair();
        const pkA = await this._a.serializePublicKey(kpA.publicKey);
        const skA = await this._a.serializePrivateKey(kpA.privateKey);
        const pkB = await this._b.serializePublicKey(kpB.publicKey);
        const skB = await this._b.serializePrivateKey(kpB.privateKey);
        return {
            publicKey: await this.deserializePublicKey(concat(new Uint8Array(pkA), new Uint8Array(pkB)).buffer),
            privateKey: await this.deserializePrivateKey(concat(new Uint8Array(skA), new Uint8Array(skB)).buffer),
        };
    }
    async deriveKeyPair(ikm) {
        const dkpPrk = await this._kdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));
        const seed = new Uint8Array(await this._kdf.labeledExpand(dkpPrk, LABEL_SK, EMPTY, 32 + 64));
        const seed1 = seed.slice(0, 32);
        const seed2 = seed.slice(32, 96);
        const kpA = await this._a.deriveKeyPair(seed1.buffer);
        const kpB = await this._b.deriveKeyPair(seed2.buffer);
        const pkA = await this._a.serializePublicKey(kpA.publicKey);
        const skA = await this._a.serializePrivateKey(kpA.privateKey);
        const pkB = await this._b.serializePublicKey(kpB.publicKey);
        const skB = await this._b.serializePrivateKey(kpB.privateKey);
        return {
            publicKey: await this.deserializePublicKey(concat(new Uint8Array(pkA), new Uint8Array(pkB)).buffer),
            privateKey: await this.deserializePrivateKey(concat(new Uint8Array(skA), new Uint8Array(skB)).buffer),
        };
    }
    async importKey(format, key, isPublic = true) {
        if (format !== "raw") {
            throw new NotSupportedError("'jwk' is not supported");
        }
        if (!(key instanceof ArrayBuffer)) {
            throw new InvalidParamError("Invalid type of key");
        }
        if (isPublic) {
            return await this.deserializePublicKey(key);
        }
        return await this.deserializePrivateKey(key);
    }
    async encap(params) {
        let ekmA = undefined;
        let ekmB = undefined;
        if (params.ekm !== undefined && !isCryptoKeyPair(params.ekm)) {
            if (params.ekm.byteLength !== 64) {
                throw new InvalidParamError("ekm must be 64 bytes in length");
            }
            ekmA = params.ekm.slice(0, 32);
            ekmB = params.ekm.slice(32);
        }
        const pkR = new Uint8Array(await this.serializePublicKey(params.recipientPublicKey));
        const pkRA = await this._a.deserializePublicKey(pkR.slice(0, this._a.publicKeySize).buffer);
        const pkRB = await this._b.deserializePublicKey(pkR.slice(this._a.publicKeySize).buffer);
        const resA = await this._a.encap({ recipientPublicKey: pkRA, ekm: ekmA });
        const resB = await this._b.encap({ recipientPublicKey: pkRB, ekm: ekmB });
        return {
            sharedSecret: concat(new Uint8Array(resA.sharedSecret), new Uint8Array(resB.sharedSecret)).buffer,
            enc: concat(new Uint8Array(resA.enc), new Uint8Array(resB.enc))
                .buffer,
        };
    }
    async decap(params) {
        const sk = isCryptoKeyPair(params.recipientKey)
            ? params.recipientKey.privateKey
            : params.recipientKey;
        const skR = new Uint8Array(await this.serializePrivateKey(sk));
        const skRA = await this._a.deserializePrivateKey(skR.slice(0, this._a.privateKeySize).buffer);
        const skRB = await this._b.deserializePrivateKey(skR.slice(this._a.privateKeySize).buffer);
        const ssA = await this._a.decap({
            recipientKey: skRA,
            enc: params.enc.slice(0, this._a.encSize),
        });
        const ssB = await this._b.decap({
            recipientKey: skRB,
            enc: params.enc.slice(this._a.encSize),
        });
        return concat(new Uint8Array(ssA), new Uint8Array(ssB))
            .buffer;
    }
    _serializePublicKey(k) {
        return new Promise((resolve, reject) => {
            if (k.type !== "public") {
                reject(new Error("Not public key"));
            }
            if (k.algorithm.name !== this.name) {
                reject(new Error(`Invalid algorithm name: ${k.algorithm.name}`));
            }
            if (k.key.byteLength !== this.publicKeySize) {
                reject(new Error(`Invalid key length: ${k.key.byteLength}`));
            }
            resolve(k.key.buffer);
        });
    }
    _deserializePublicKey(k) {
        return new Promise((resolve, reject) => {
            if (k.byteLength !== this.publicKeySize) {
                reject(new Error(`Invalid key length: ${k.byteLength}`));
            }
            resolve(new XCryptoKey(this.name, new Uint8Array(k), "public"));
        });
    }
    _serializePrivateKey(k) {
        return new Promise((resolve, reject) => {
            if (k.type !== "private") {
                reject(new Error("Not private key"));
            }
            if (k.algorithm.name !== this.name) {
                reject(new Error(`Invalid algorithm name: ${k.algorithm.name}`));
            }
            if (k.key.byteLength !== this.privateKeySize) {
                reject(new Error(`Invalid key length: ${k.key.byteLength}`));
            }
            resolve(k.key.buffer);
        });
    }
    _deserializePrivateKey(k) {
        return new Promise((resolve, reject) => {
            if (k.byteLength !== this.privateKeySize) {
                reject(new Error(`Invalid key length: ${k.byteLength}`));
            }
            resolve(new XCryptoKey(this.name, new Uint8Array(k), "private", ["deriveBits"]));
        });
    }
}
