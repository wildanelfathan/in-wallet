import{z as e}from"zod";import{InvalidInputError as r,PrivyErrorCode as t}from"@privy-io/api-base";import{TypedDataTypesInputParams as i,ChainType as a,OwnerInputFields as n,KeyQuorumId as o}from"./wallet-api/wallets.mjs";import"./api.mjs";import"./core.mjs";import"bs58";import"libphonenumber-js/max";import"viem";import"./transaction.mjs";import"./wallet-api/export.mjs";const s=e.enum(["ALLOW","DENY"]);let l=e.union([e.string(),e.number(),e.boolean(),e.null()]),c=e.lazy((()=>e.union([l,e.array(c),e.record(c)])));const m=e.union([e.literal("eq"),e.literal("gt"),e.literal("gte"),e.literal("lt"),e.literal("lte"),e.literal("in")]),d=e.object({operator:m,value:e.union([e.string(),e.array(e.string())])}),u=e.object({field_source:e.literal("ethereum_transaction"),field:e.union([e.literal("to"),e.literal("value")])}).strict().merge(d),_=e.object({field_source:e.literal("ethereum_calldata"),field:e.string(),abi:c}).strict().merge(d),p=e.object({field_source:e.literal("ethereum_typed_data_domain"),field:e.union([e.literal("chainId"),e.literal("verifyingContract"),e.literal("chain_id"),e.literal("verifying_contract")])}).strict().merge(d),f=e.object({field_source:e.literal("ethereum_typed_data_message"),field:e.string(),typed_data:e.object({types:i,primary_type:e.string()})}).strict().merge(d),h=e.object({field_source:e.literal("ethereum_7702_authorization"),field:e.literal("contract")}).strict().merge(d),g=e.object({field_source:e.literal("solana_program_instruction"),field:e.literal("programId")}).strict().merge(d),y=e.object({field_source:e.literal("solana_system_program_instruction"),field:e.union([e.literal("instructionName"),e.literal("Transfer.from"),e.literal("Transfer.to"),e.literal("Transfer.lamports")])}).strict().merge(d),b=e.object({field_source:e.literal("solana_token_program_instruction"),field:e.union([e.literal("instructionName"),e.literal("TransferChecked.source"),e.literal("TransferChecked.destination"),e.literal("TransferChecked.authority"),e.literal("TransferChecked.amount"),e.literal("TransferChecked.mint")])}).strict().merge(d),w=e.discriminatedUnion("field_source",[u,_,p,f,h,g,y,b]),v=e.object({name:e.string().max(50,"Rule name must be fewer than 50 characters"),conditions:e.array(w),action:s}).strict();let j=e.union([e.literal("eth_sendTransaction"),e.literal("eth_signTransaction"),e.literal("eth_signTypedData_v4"),e.literal("eth_sign7702Authorization"),e.literal("signTransaction"),e.literal("signAndSendTransaction"),e.literal("exportPrivateKey"),e.literal("*")]),T=e.object({method:j,rules:e.array(v)}).strict().transform((e=>{let r=[];for(let t of e.rules){let i=A.parse({name:t.name,method:e.method,conditions:t.conditions,action:t.action});r.push(i)}return r}));const A=e.object({name:e.string().max(50,"Rule name must be fewer than 50 characters"),method:j,conditions:e.array(w),action:s}).strict(),x=A.extend({id:e.string()}).strict(),I=A.extend({id:e.string().optional()}).strict();function D(e){return e.toLowerCase().replace(/ /g,"-")+"-"+crypto.randomUUID().slice(0,8)}const L=e.object({policy_id:e.string().min(1),rule_id:e.string().min(1)}).catch((({error:e})=>{throw new r(e.message,t.INVALID_DATA)}));let O=e.object({version:e.literal("1.0"),name:e.string().max(50,"Policy name must be fewer than 50 characters"),chain_type:a,method_rules:e.array(T),default_action:s,...n}).strict(),C=e.object({version:e.literal("1.0"),name:e.string().max(50,"Policy name must be fewer than 50 characters"),chain_type:a,rules:e.array(I),...n}).strict();const N=e.union([O,C]).transform((e=>{if(!("method_rules"in e))return e;{let r={version:e.version,name:e.name,chain_type:e.chain_type,rules:e.method_rules.flat(),owner:e.owner,owner_id:e.owner_id};return"ALLOW"===e.default_action&&r.rules.push(I.parse({name:"Default Action",method:"*",conditions:[],action:s.enum.ALLOW})),C.parse(r)}})).refine((e=>!e.owner||!e.owner_id),{message:"Only one of owner or owner_id can be provided."}),P=C.omit({owner:!0,owner_id:!0}).extend({id:e.string(),created_at:e.number(),owner_id:o.nullable(),rules:e.array(x)}),k=e.object({policy_id:e.string({required_error:"Policy ID must be provided",invalid_type_error:"Policy ID is not a valid string"}).min(1)}).catch((({error:e})=>{throw new r(e.message,t.INVALID_DATA)}));let q=e.object({name:e.string().trim().min(1,"Name is required").max(50,"Policy name must be fewer than 50 characters").optional(),method_rules:e.array(T).optional(),...n}).strict().superRefine(((e,r)=>{Object.values(e).every((e=>void 0===e||""===e))&&r.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==e.owner&&void 0!==e.owner_id&&r.addIssue({code:"custom",message:"Only one of owner or owner_id can be provided."})})),z=e.object({name:e.string().trim().min(1,"Name is required").max(50,"Policy name must be fewer than 50 characters").optional(),rules:e.array(A).optional(),...n}).strict().superRefine(((e,r)=>{Object.values(e).every((e=>void 0===e||""===e))&&r.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==e.owner&&void 0!==e.owner_id&&r.addIssue({code:"custom",message:"Only one of owner or owner_id can be provided."})}));const R=e.union([q,z]).transform((e=>"method_rules"in e?z.parse({name:e.name,rules:e.method_rules?.flat()??[],owner:e.owner,owner_id:e.owner_id}):z.parse(e)));export{d as BaseCondition,w as Condition,m as ConditionOperator,h as Ethereum7702AuthorizationCondition,_ as EthereumCalldataCondition,u as EthereumTransactionCondition,p as EthereumTypedDataDomainCondition,f as EthereumTypedDataMessageCondition,v as LegacyRule,s as PolicyAction,k as PolicyIdFromPath,P as PolicyResponse,N as PolicyWithoutValidation,I as Rule,L as RuleIdAndPolicyIdFromPath,A as RuleInput,x as RuleResponse,g as SolanaProgramInstruction,y as SolanaSystemProgramInstruction,b as SolanaTokenProgramInstruction,R as UpdatePolicyInput,D as generateRuleIdFromName};
