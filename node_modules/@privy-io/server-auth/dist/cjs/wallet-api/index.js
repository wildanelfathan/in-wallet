"use strict";var e=require("../errors.js"),a=require("../paths.js"),t=require("../utils-2_PewCqC.js"),i=require("./mappers.js"),r=require("./rpc/ethereum.js"),n=require("./rpc/solana.js"),o=require("./utils.js");function s(e,a){if(!Object.prototype.hasOwnProperty.call(e,a))throw TypeError("attempted to use private field on non-instance");return e}require("node-fetch-native"),require("ts-case-convert"),require("@hpke/chacha20poly1305"),require("@hpke/core"),require("@noble/curves/p256"),require("@noble/hashes/sha256"),require("canonicalize"),require("../constants.js");var d=0,c="__private_"+d+++"__getRequestHeaders";function p({path:e,body:a,idempotencyKey:t,method:i}){let r=o.extractIdempotencyKeyHeader({idempotencyKey:t}),n={...r};if(this.authorizationPrivateKey){let t=o.signAuthorizationSignatureRequest({method:i,url:`${this.api.baseURL}${e}`,body:a,appId:this.appId,idempotencyKeyHeader:r,authorizationPrivateKey:this.authorizationPrivateKey});void 0!==t&&(n["privy-authorization-signature"]=t)}return n}exports.WalletApi=class{async getWallets(e={}){let{cursor:i,limit:r,chainType:n}=e,{data:o}=await this.api.get(a.getWalletApiSearchPath()+t.getQueryParamsString({cursor:i,limit:r,chain_type:n}));return{nextCursor:o.next_cursor??void 0,data:o.data.map((e=>({id:e.id,address:e.address,chainType:e.chain_type,policyIds:e.policy_ids,createdAt:new Date(e.created_at)})))}}async getWallet({id:e}){let{data:t}=await this.api.get(a.getWalletApiGetPath(e));return{id:t.id,chainType:t.chain_type,address:t.address,policyIds:t.policy_ids,createdAt:new Date(t.created_at)}}updateAuthorizationKey(e){this.authorizationPrivateKey=o.normalizeP256PrivateKeyToScalar(e),this.ethereum=new r.EthereumRpcApi({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new n.SolanaRpcApi({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey})}async generateUserSigner({userJwt:e}){let{publicKey:a,privateKey:t}=await o.createP256KeyPair(),{data:i}=await this.api.post("/api/v1/user_signers/authenticate",{encryption_type:"HPKE",recipient_public_key:a.toString("base64"),user_jwt:e});return{authorizationKey:await o.decryptHPKEMessage(t.toString("base64"),i.encrypted_authorization_key.encapsulated_key,i.encrypted_authorization_key.ciphertext),expiresAt:new Date(i.expires_at),wallets:i.wallets.map((e=>({id:e.id,address:e.address,chainType:e.chain_type,policyIds:e.policy_ids,createdAt:new Date(e.created_at)})))}}async getPolicy({id:e}){let{data:t}=await this.api.get(a.getPolicyPath(e));return i.convertPolicyResponseToPolicy(t)}async createPolicy(e){let t=a.createPolicyPath(),r=i.convertPolicyCreateRequestToPolicy(e),{data:n}=await this.api.post(t,r,{headers:s(this,c)[c]({path:t,body:r,method:"POST"})});return i.convertPolicyResponseToPolicy(n)}async updatePolicy(e){let t=a.updatePolicyPath(e.id),r={name:e.name,rules:e.rules?i.convertPolicyCreateRuleToPolicyRule(e.rules):void 0},{data:n}=await this.api.patch(t,r,{headers:s(this,c)[c]({path:t,body:r,method:"PATCH"})});return i.convertPolicyResponseToPolicy(n)}async deletePolicy(e){let t=a.deletePolicyPath(e.id),i={};await this.api.delete(t,i,{headers:s(this,c)[c]({path:t,body:i,method:"DELETE"})})}async addRuleToPolicy(e){let t=a.createPolicyRulePath(e.policyId),i={name:e.name,action:e.action,method:e.method,conditions:e.conditions},{data:r}=await this.api.post(t,i,{headers:s(this,c)[c]({path:t,body:i,method:"POST"})});return r}async updateRuleInPolicy(e){let t=a.updatePolicyRulePath(e.policyId,e.ruleId),i={name:e.name,action:e.action,method:e.method,conditions:e.conditions},{data:r}=await this.api.patch(t,i,{headers:s(this,c)[c]({path:t,body:i,method:"PATCH"})});return r}async deleteRuleFromPolicy(e){let t=a.deletePolicyRulePath(e.policyId,e.ruleId),i={};await this.api.delete(t,i,{headers:s(this,c)[c]({path:t,body:i,method:"DELETE"})})}async getRuleInPolicy(e){let t=a.getPolicyRulePath(e.policyId),{data:i}=await this.api.get(t);return i}async getTransaction({id:e}){let{data:t}=await this.api.get(a.getTransactionGetPath(e));return{id:t.id,walletId:t.wallet_id,caip2:t.caip2,transactionHash:t.transaction_hash,status:t.status}}async create(e){return await this.createWallet(e)}async createWallet(t){let{chainType:i,authorizationKeyIds:r,authorizationThreshold:n}=t,s={};if("ownerId"in t&&t.ownerId)s={owner_id:t.ownerId};else if("owner"in t&&t.owner)if("publicKey"in t.owner&&t.owner.publicKey)s={owner:{public_key:t.owner.publicKey}};else{if(!("userId"in t.owner)||!t.owner.userId)throw new e.PrivyClientError("Invalid owner input. Must include either `publicKey` or `userId`.");s={owner:{user_id:t.owner.userId}}}let d={};"authorizationKeyIds"in t||"authorizationThreshold"in t?d={authorization_key_ids:r,authorization_threshold:n}:"additionalSigners"in t&&t.additionalSigners&&(d={additional_signers:t.additionalSigners.map((e=>({signer_id:e.signerId})))});let c={chain_type:i,...s,...d},p=o.extractIdempotencyKeyHeader(t),h=o.createAuthorizationSignatureHeader({method:"POST",url:`${this.api.baseURL}${a.getWalletApiCreatePath()}`,body:c,appId:this.appId,idempotencyKeyHeader:p,authorizationPrivateKey:this.authorizationPrivateKey}),{data:l}=await this.api.post(a.getWalletApiCreatePath(),c,{headers:{...h,...p}});return{id:l.id,address:l.address,chainType:l.chain_type,policyIds:l.policy_ids,createdAt:new Date(l.created_at)}}async rpc(t){let i;if("walletId"in t)i=a.getWalletApiRpcPath(t.walletId);else{if(!("address"in t))throw new e.PrivyClientError("Invalid RPC payload. Must include `walletId`.");{console.warn("Warning: using deprecated input 'address' this will be removed in a a future version. Use 'walletId' instead.");let r=await o.getWalletIdFromAddress(this.api,t.address);if(!r)throw new e.PrivyClientError(`No wallet account found for address ${t.address}`);i=a.getWalletApiRpcPath(r)}}let r=function(e){let{method:a,params:t}=e,i="address"in e?{address:e.address,chain_type:e.chainType}:{wallet_id:e.walletId};switch(a){case"signTransaction":return{...i,method:a,params:{transaction:Buffer.from(t.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"signMessage":{let e=Buffer.from(t.message).toString("base64");return{...i,method:a,params:{message:e,encoding:"base64"}}}case"signAndSendTransaction":return{...i,method:a,caip2:e.caip2,params:{transaction:Buffer.from(t.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"eth_signTransaction":return{...i,method:a,params:{transaction:{from:t.transaction.from,to:t.transaction.to,nonce:t.transaction.nonce,chain_id:t.transaction.chainId,data:t.transaction.data,value:t.transaction.value,type:t.transaction.type,gas_limit:t.transaction.gasLimit,gas_price:t.transaction.gasPrice,max_fee_per_gas:t.transaction.maxFeePerGas,max_priority_fee_per_gas:t.transaction.maxPriorityFeePerGas}}};case"personal_sign":let r;return r=t.message instanceof Uint8Array?{message:Buffer.from(t.message).toString("hex"),encoding:"hex"}:t.message.startsWith("0x")?{message:t.message,encoding:"hex"}:{message:t.message,encoding:"utf-8"},{...i,method:a,params:r};case"eth_signTypedData_v4":return{...i,method:a,params:{typed_data:{domain:t.typedData.domain,types:t.typedData.types,message:t.typedData.message,primary_type:t.typedData.primaryType}}};case"eth_sendTransaction":return{...i,method:a,caip2:e.caip2,params:{transaction:{from:t.transaction.from,to:t.transaction.to,nonce:t.transaction.nonce,chain_id:t.transaction.chainId,data:t.transaction.data,value:t.transaction.value,type:t.transaction.type,gas_limit:t.transaction.gasLimit,gas_price:t.transaction.gasPrice,max_fee_per_gas:t.transaction.maxFeePerGas,max_priority_fee_per_gas:t.transaction.maxPriorityFeePerGas}}};default:throw Error(`Unsupported method: ${a}`)}}(t),n=o.extractIdempotencyKeyHeader(t),s=o.createAuthorizationSignatureHeader({method:"POST",url:`${this.api.baseURL}${i}`,body:r,appId:this.appId,idempotencyKeyHeader:n,authorizationPrivateKey:this.authorizationPrivateKey}),{data:d}=await this.api.post(i,r,{headers:{...s,...n}});return await async function(e,a){switch(a.method){case"signMessage":return{method:a.method,data:{signature:Buffer.from(a.data.signature,"base64")}};case"signTransaction":let t,i=e.params.transaction,r=Buffer.from(a.data.signed_transaction,"base64"),{Transaction:n,VersionedTransaction:o}=await import("@solana/web3.js");return t="version"in i?o.deserialize(r):n.from(r),{method:a.method,data:{signedTransaction:t}};case"signAndSendTransaction":if(a.data)return{method:a.method,data:{transactionId:a.data.transaction_id,hash:a.data.hash,caip2:a.data.caip2}};if(a.error)return{method:a.method,error:{code:a.error.code,message:a.error.message}};throw Error("Unexpected API response to signAndSendTransaction");case"eth_signTransaction":return{method:a.method,data:{signedTransaction:a.data.signed_transaction,encoding:a.data.encoding}};case"eth_sendTransaction":if(a.data)return{method:a.method,data:{transactionId:a.data.transaction_id,hash:a.data.hash,caip2:a.data.caip2}};if(a.error)return{method:a.method,error:{code:a.error.code,message:a.error.message}};throw Error("Unexpected API response to eth_sendTransaction");case"personal_sign":case"eth_signTypedData_v4":return{method:a.method,data:{signature:a.data.signature,encoding:a.data.encoding}};default:throw Error("Unsupported method")}}(t,d)}constructor({appId:e,api:a,authorizationPrivateKey:t}){Object.defineProperty(this,c,{value:p}),this.authorizationPrivateKey=null,this.api=a,t&&(this.authorizationPrivateKey=o.normalizeP256PrivateKeyToScalar(t)),this.appId=e,this.ethereum=new r.EthereumRpcApi({appId:e,api:a,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new n.SolanaRpcApi({appId:e,api:a,authorizationPrivateKey:this.authorizationPrivateKey})}},exports.formatRequestForAuthorizationSignature=function({input:e}){return o.formatAuthorizationSignatureRequest({method:e.method,body:e.body,url:e.url,appId:e.headers["privy-app-id"],idempotencyKeyHeader:e.headers["privy-idempotency-key"]?{"privy-idempotency-key":e.headers["privy-idempotency-key"]}:void 0})},exports.generateAuthorizationSignature=function({input:e,authorizationPrivateKey:a}){let t;try{t=o.normalizeP256PrivateKeyToScalar(a)}catch(e){throw Error("Invalid authorization key format. Expected Privy-specific Authorization private key (wallet-auth:...)")}return o.signAuthorizationSignatureRequest({method:e.method,url:e.url,body:e.body,appId:e.headers["privy-app-id"],idempotencyKeyHeader:e.headers["privy-idempotency-key"]?{"privy-idempotency-key":e.headers["privy-idempotency-key"]}:void 0,authorizationPrivateKey:t})};
