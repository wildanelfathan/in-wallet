"use strict";var e=require("@hpke/chacha20poly1305"),r=require("@hpke/core"),t=require("@noble/curves/p256"),a=require("@noble/hashes/sha256"),i=require("canonicalize"),o=require("../constants.js"),n=require("../errors.js"),d=require("../paths.js");function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var u=/*#__PURE__*/s(i);const p=e=>Buffer.from(u.default(e)),l=(e,r)=>{let i=t.p256.sign(a.sha256(e),r).toDERRawBytes();return Buffer.from(i)},y=({method:e,url:r,body:t,appId:a,idempotencyKeyHeader:i})=>{let o={version:1,method:e,url:r,body:t,headers:{"privy-app-id":a,...i}};return p(o)},c=({method:e,url:r,body:t,appId:a,idempotencyKeyHeader:i,authorizationPrivateKey:o})=>{if("bigint"!=typeof o)return;let n=y({method:e,url:r,body:t,appId:a,idempotencyKeyHeader:i});return l(n,o).toString("base64")};async function f(e,r){let t=d.getUserByWalletAddressPath(),a=(await e.post(t,{address:r})).data.linked_accounts.find((e=>"wallet"===e.type&&e.address===r));return a?.id}exports.createAuthorizationSignatureHeader=({method:e,body:r,url:t,appId:a,idempotencyKeyHeader:i,authorizationPrivateKey:o})=>{let n=c({method:e,body:r,url:t,appId:a,idempotencyKeyHeader:i,authorizationPrivateKey:o});if(n)return{"privy-authorization-signature":n}},exports.createP256KeyPair=async function(){let e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),r=await crypto.subtle.exportKey("spki",e.publicKey),t=await crypto.subtle.exportKey("pkcs8",e.privateKey);return{publicKey:Buffer.from(r),privateKey:Buffer.from(t)}},exports.decryptHPKEMessage=async function(t,a,i){let o=new r.CipherSuite({kem:new r.DhkemP256HkdfSha256,kdf:new r.HkdfSha256,aead:new e.Chacha20Poly1305}),n=await crypto.subtle.importKey("pkcs8",Uint8Array.from(atob(t),(e=>e.charCodeAt(0))).buffer,{name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]),d=await o.createRecipientContext({recipientKey:n,enc:Uint8Array.from(atob(a),(e=>e.charCodeAt(0))).buffer});return(new TextDecoder).decode(await d.open(Uint8Array.from(atob(i),(e=>e.charCodeAt(0))).buffer))},exports.extractIdempotencyKeyHeader=e=>{if(void 0!==e.idempotencyKey)return{"privy-idempotency-key":e.idempotencyKey}},exports.formatAuthorizationSignatureRequest=y,exports.getRpcPathForRequest=async(e,r)=>{let t;if("walletId"in e)t=d.getWalletApiRpcPath(e.walletId);else{if(!("address"in e))throw new n.PrivyClientError("Invalid RPC payload. Must include `walletId`.");{console.warn("Warning: using deprecated input 'address' this will be removed in a a future version. Use 'walletId' instead.");let a=await f(r,e.address);if(!a)throw new n.PrivyClientError(`No wallet account found for address ${e.address}`);t=d.getWalletApiRpcPath(a)}}return t},exports.getWalletIdFromAddress=f,exports.normalizeP256PrivateKeyToScalar=e=>{let r=e.replace(o.AUTHORIZATION_PRIVATE_KEY_PREFIX,"").replace(o.WALLET_API_PRIVATE_KEY_PREFIX,""),a=Buffer.from(r,"base64"),i=a.indexOf(Buffer.from([4,32]));if(-1===i)throw new n.PrivyClientError("Invalid wallet authorization private key");let d=a.subarray(i+2,i+34);return t.p256.utils.normPrivateKeyToScalar(d)},exports.serializePayloadToBuffer=p,exports.signAuthorizationSignatureRequest=c,exports.signWithP256=l;
