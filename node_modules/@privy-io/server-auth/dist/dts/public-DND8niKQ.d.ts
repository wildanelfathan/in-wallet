import * as _solana_web3_js from '@solana/web3.js';
import { Transaction, VersionedTransaction } from '@solana/web3.js';
import * as redaxios from 'redaxios';
import redaxios__default from 'redaxios';
import { ChainType, CustomMetadataType, SmartWalletType, Prettify, PolicyActionType } from '@privy-io/public-api';

type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
type LinkedAccountType = 'wallet' | 'smart_wallet' | 'email' | 'phone' | 'google_oauth' | 'twitter_oauth' | 'discord_oauth' | 'github_oauth' | 'apple_oauth' | 'linkedin_oauth' | 'tiktok_oauth' | 'spotify_oauth' | 'instagram_oauth' | 'custom_auth' | 'farcaster' | 'telegram' | 'cross_app' | 'passkey';
/** @ignore */
interface LinkMetadata {
    /** Account type, most commonly useful when filtering through linkedAccounts */
    type: LinkedAccountType;
    /**
     * @deprecated use `firstVerifiedAt` instead.
     * Datetime when this account was linked to the user or created. */
    verifiedAt: Date;
    /** Datetime when this account was linked to the user. */
    firstVerifiedAt: Date | null;
    /** Datetime when this account was most recently used as a login/link method by the user. */
    latestVerifiedAt: Date | null;
}
/**
 * Object representation of a user's wallet.
 */
interface Wallet {
    /** The server wallet ID of the wallet. Null if the wallet is not delegated and not on the unified wallets stack. Only applies to embedded wallets (`walletClientType === 'privy'`). */
    id?: string | null;
    /** The wallet address. */
    address: string;
    /**
     * Chain type of the wallet address.
     *
     * e.g. `ethereum`, `solana`
     */
    chainType: ChainType;
    /**
     * @deprecated Use `chainType` instead.
     *
     * CAIP-2 formatted chain ID during the most recent verification.
     *
     * e.g. eip155:1, eip155:5, eip155:137, etc.
     */
    chainId?: string;
    /**
     * @deprecated Use `walletClientType` instead.
     */
    walletType?: string;
    /**
     * The wallet client used for this wallet during the most recent verification.
     *
     * If the value is `privy`, then this is a privy embedded wallet.
     *
     * Other values include but are not limited to `metamask`, `rainbow`, `coinbase_wallet`, etc.
     */
    walletClientType?: string;
    /**
     * The connector type used for this wallet during the most recent verification.
     *
     * This includes but is not limited to `injected`, `wallet_connect`, `coinbase_wallet`, `embedded`.
     */
    connectorType?: string;
    /**
     * The index of this wallet for an HD wallet, if the wallet is an embedded wallet.
     */
    hdWalletIndex?: number;
    /**
     * Whether or not this wallet was imported by the user. Will be undefined if the wallet is not
     * an embedded wallet.
     */
    imported?: boolean;
    /**
     * Whether or not this wallet was delegated by the user. Will be undefined if the wallet is not
     * an embedded wallet.
     */
    delegated?: boolean;
}
/** Object representation of a user's email. */
interface Email {
    /** The email address. */
    address: string;
}
/**
 * Object representation of a smart wallet.
 */
interface SmartWallet {
    /** The wallet address. */
    address: string;
    /** The provider of the smart wallet. */
    smartWalletType: SmartWalletType;
}
/** Object representation of a user's phone number. */
interface Phone {
    /** The phone number. */
    number: string;
}
/** Object representation of a user's Google account. */
interface Google {
    /** The `sub` claim from the Google-issued JWT for this account. */
    subject: string;
    /** The email associated with the Google account. */
    email: string;
    /** The name associated with the Google account. */
    name: string | null;
}
/** Object representation of a user's Twitter account. */
interface Twitter {
    /** The `sub` claim from the Twitter-issued JWT for this account. */
    subject: string;
    /** The username associated with the Twitter account. */
    username: string | null;
    /** The name associated with the Twitter account. */
    name: string | null;
    /** The profile picture URL associated with the Twitter account. */
    profilePictureUrl?: string | null;
}
/** Object representation of a user's Discord account. */
interface Discord {
    /** The `sub` claim from the Discord-issued JWT for this account. */
    subject: string;
    /** The username associated with the Discord account.  */
    username: string | null;
    /** The email associated with the Discord account. */
    email: string | null;
}
/** Object representation of a user's Github account. */
interface Github {
    /** The `sub` claim from the Github-issued JWT for this account. */
    subject: string;
    /** The username associated with the Github account.  */
    username: string | null;
    /** The email associated with the Github account. */
    email: string | null;
    /** The name associated with the Github account. */
    name: string | null;
}
/** Object representation of a user's Apple account. */
interface Apple {
    /** The `sub` claim from the Apple-issued JWT for this account. */
    subject: string;
    /** The email associated with the Apple account. */
    email: string;
}
/** Object representation of a user's LinkedIn account. */
interface LinkedIn {
    /** The `sub` claim from the LinkedIn-issued JWT for this account. */
    subject: string;
    /** The email associated with the LinkedIn account. */
    email: string;
    /** The name associated with the LinkedIn account. */
    name: string;
    /** The vanity name associated with the LinkedIn account. */
    vanityName?: string;
}
/** Object representation of a user's Tiktok account. */
interface Tiktok {
    /** The `sub` claim from the Tiktok-issued JWT for this account. */
    subject: string;
    /** The username associated with the Tiktok account. */
    username?: string;
    /** The name associated with the Tiktok account. */
    name: string;
}
interface Spotify {
    /** The `sub` claim from the Spotify-issued JWT for this account. */
    subject: string;
    /** The email associated with the Spotify account. */
    email?: string;
    /** The name associated with the Spotify account. */
    name?: string;
}
interface Instagram {
    /** The `sub` claim from the Instagram-issued JWT for this account. */
    subject: string;
    /** The username associated with the Instagram account. */
    username: string;
}
interface Telegram {
    telegramUserId: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    photoUrl?: string;
}
interface Farcaster {
    fid: number;
    ownerAddress: string;
    username?: string;
    displayName?: string;
    bio?: string;
    pfp?: string;
    url?: string;
}
/** Metadata about the provider app for a cross-app account */
interface ProviderAppMetadata {
    /** Privy app ID for the provider app. */
    id: string;
    /** Name for the provider app. */
    name?: string;
    /** Logo URL for the provider app. */
    logoUrl?: string;
}
interface CrossAppEmbeddedWallet {
    address: string;
}
interface CrossAppSmartWallet {
    address: string;
}
interface CrossAppAccount {
    /** The user's embedded wallet address(es) from the provider app */
    embeddedWallets: CrossAppEmbeddedWallet[];
    smartWallets: CrossAppSmartWallet[];
    providerApp: ProviderAppMetadata;
    subject: string;
}
interface PasskeyAccount {
    credentialId: string;
}
/** Object representation of a user's Custom JWT account. */
interface CustomJwt {
    /** The `sub` claim (or specified attribute in console configuration) from the Custom JWT for this account. */
    customUserId: string;
}
/** Object representation of a user's email, with additional metadata for advanced use cases. */
interface EmailWithMetadata extends LinkMetadata, Email {
    /** Denotes that this is an email account. */
    type: 'email';
}
/** Object representation of a user's phone number, with additional metadata for advanced use cases. */
interface PhoneWithMetadata extends LinkMetadata, Phone {
    /** Denotes that this is a phone account. */
    type: 'phone';
}
/** Object representation of a user's wallet, with additional metadata for advanced use cases. */
interface WalletWithMetadata extends LinkMetadata, Wallet {
    /** Denotes that this is a wallet account. */
    type: 'wallet';
}
interface SmartWalletWithMetadata extends LinkMetadata, SmartWallet {
    /** Denotes that this is a smart wallet account. */
    type: 'smart_wallet';
}
/** Object representation of a user's Google Account, with additional metadata for advanced use cases. */
interface GoogleOAuthWithMetadata extends LinkMetadata, Google {
    /** Denotes that this is a Google account. */
    type: 'google_oauth';
}
/** Object representation of a user's Twitter Account, with additional metadata for advanced use cases. */
interface TwitterOAuthWithMetadata extends LinkMetadata, Twitter {
    /** Denotes that this is a Twitter account. */
    type: 'twitter_oauth';
}
/** Object representation of a user's Discord Account, with additional metadata for advanced use cases. */
interface DiscordOAuthWithMetadata extends LinkMetadata, Discord {
    /** Denotes that this is a Discord account. */
    type: 'discord_oauth';
}
/** Object representation of a user's Github Account, with additional metadata for advanced use cases. */
interface GithubOAuthWithMetadata extends LinkMetadata, Github {
    /** Denotes that this is a Github account. */
    type: 'github_oauth';
}
/** Object representation of a user's Apple Account, with additional metadata for advanced use cases. */
interface AppleOAuthWithMetadata extends LinkMetadata, Apple {
    /** Denotes that this is a Apple account. */
    type: 'apple_oauth';
}
/** Object representation of a user's LinkedIn Account, with additional metadata for advanced use cases. */
interface LinkedInOAuthWithMetadata extends LinkMetadata, LinkedIn {
    /** Denotes that this is a LinkedIn account. */
    type: 'linkedin_oauth';
}
/** Object representation of a user's Tiktok Account, with additional metadata for advanced use cases. */
interface TiktokOAuthWithMetadata extends LinkMetadata, Tiktok {
    /** Denotes that this is a Tiktok account. */
    type: 'tiktok_oauth';
}
/** Object representation of a user's Spotify Account, with additional metadata for advanced use cases. */
interface SpotifyOAuthWithMetadata extends LinkMetadata, Spotify {
    /** Denotes that this is a Spotify account. */
    type: 'spotify_oauth';
}
/** Object representation of a user's Instagram Account, with additional metadata for advanced use cases. */
interface InstagramOAuthWithMetadata extends LinkMetadata, Instagram {
    /** Denotes that this is an Instagram account. */
    type: 'instagram_oauth';
}
/** Object representation of a user's Custom JWT Account, with additional metadata for advanced use cases. */
interface CustomJwtWithMetadata extends LinkMetadata, CustomJwt {
    /** Denotes that this is a Custom JWT account. */
    type: 'custom_auth';
}
interface FarcasterWithMetadata extends LinkMetadata, Farcaster {
    /** Denotes that this is a Farcaster account. */
    type: 'farcaster';
}
interface TelegramWithMetadata extends LinkMetadata, Telegram {
    /** Denotes that this is a Telegram account. */
    type: 'telegram';
}
/** Object representation of a user's cross-app account, with additional metadata for advanced use cases. */
interface CrossAppAccountWithMetadata extends LinkMetadata, CrossAppAccount {
    /** Denotes that this is a cross-app account */
    type: 'cross_app';
}
interface PasskeyAccountWithMetadata extends LinkMetadata, PasskeyAccount {
    /** Denotes that this is a passkey account */
    type: 'passkey';
}
/** Generic object representation of a linked account */
type LinkedAccountWithMetadata = WalletWithMetadata | SmartWalletWithMetadata | EmailWithMetadata | PhoneWithMetadata | GoogleOAuthWithMetadata | TwitterOAuthWithMetadata | DiscordOAuthWithMetadata | GithubOAuthWithMetadata | AppleOAuthWithMetadata | LinkedInOAuthWithMetadata | TiktokOAuthWithMetadata | SpotifyOAuthWithMetadata | InstagramOAuthWithMetadata | CustomJwtWithMetadata | FarcasterWithMetadata | TelegramWithMetadata | CrossAppAccountWithMetadata | PasskeyAccountWithMetadata;
type LinkedAccountInput = Array<DistributiveOmit<LinkedAccountWithMetadata, 'verifiedAt' | 'firstVerifiedAt' | 'latestVerifiedAt'>>;
interface AdditionalSignerInput {
    /** The public key of the additional signer. */
    signerId: string;
    /** The policy IDs that apply to the additional signer. */
    policyIds: string[];
}
interface EmbeddedWalletCreationInput {
    /** The wallet chain type. */
    additionalSigners?: AdditionalSignerInput[];
    /** The policy IDs that apply to the embedded wallet. */
    policyIds: string[];
    /** The wallet chain type. */
    chainType: ChainType;
    /** If true, create a smart wallet with the embedded wallet as the signer. Defaults to false. */
    createSmartWallet?: boolean;
}
interface CreateWalletInput {
    /** The user's Privy-issued DID. */
    userId: string;
    /** The wallets to create for this user. */
    wallets?: EmbeddedWalletCreationInput[];
    /** If true, create an Ethereum embedded wallet for this user. Defaults to false. */
    createEthereumWallet?: boolean;
    /** If true, create a Solana embedded wallet for this user. Defaults to false. */
    createSolanaWallet?: boolean;
    /**
     * If true, create a smart wallet for this user. Defaults to false.
     * Requires `createEthereumWallet` to also be true.
     */
    createEthereumSmartWallet?: boolean;
    /**
     * The number of HD Ethereum embedded wallets to create for this user. Defaults to 1.
     * Requires `createEthereumWallet` to also be true.
     */
    numberOfEthereumWalletsToCreate?: number;
}
interface ImportUserInput {
    /** The user's linked accounts. */
    linkedAccounts: LinkedAccountInput;
    /** The wallets to create for this user. */
    wallets?: EmbeddedWalletCreationInput[];
    /** If true, create an Ethereum embedded wallet for this user. Defaults to false. */
    createEthereumWallet?: boolean;
    /** If true, create a Solana embedded wallet for this user. Defaults to false. */
    createSolanaWallet?: boolean;
    /**
     * If true, create a smart wallet for this user. Defaults to false.
     * Requires `createEthereumWallet` to also be true.
     */
    createEthereumSmartWallet?: boolean;
    /** Custom metadata to associate with the user. */
    customMetadata?: CustomMetadataType;
    /** @deprecated Use `createEthereumWallet` instead. */
    createEmbeddedWallet?: boolean;
}
interface User {
    /** The Privy-issued DID for the user. If you need to store additional information
     * about a user, you can use this DID to reference them. */
    id: string;
    /** The datetime of when the user was created. */
    createdAt: Date;
    /** Whether or not the user is a guest. */
    isGuest: boolean;
    /** Custom metadata set for the user */
    customMetadata: CustomMetadataType;
    /** The user's email address, if they have linked one. It cannot be linked to another user. */
    email?: Omit<EmailWithMetadata, 'type'>;
    /** The user's phone number, if they have linked one. It cannot be linked to another user. */
    phone?: Omit<PhoneWithMetadata, 'type'>;
    /** The user's most recently-linked wallet address, if they have linked at least one wallet.
     * It cannot be linked to another user.
     **/
    wallet?: Omit<WalletWithMetadata, 'type'>;
    /**
     * The user's smart wallet, if they have set up through the Privy Smart Wallet SDK.
     */
    smartWallet?: Omit<SmartWalletWithMetadata, 'type'>;
    /** The user's Google account, if they have linked one. It cannot be linked to another user. */
    google?: Omit<GoogleOAuthWithMetadata, 'type'>;
    /** The user's Twitter account, if they have linked one. It cannot be linked to another user. */
    twitter?: Omit<TwitterOAuthWithMetadata, 'type'>;
    /** The user's Discord account, if they have linked one. It cannot be linked to another user. */
    discord?: Omit<DiscordOAuthWithMetadata, 'type'>;
    /** The user's Github account, if they have linked one. It cannot be linked to another user. */
    github?: Omit<GithubOAuthWithMetadata, 'type'>;
    /** The user's Apple account, if they have linked one. It cannot be linked to another user. */
    apple?: Omit<AppleOAuthWithMetadata, 'type'>;
    /** The user's Tiktok account, if they have linked one. It cannot be linked to another user. */
    tiktok?: Omit<TiktokOAuthWithMetadata, 'type'>;
    /** The user's LinkedIn account, if they have linked one. It cannot be linked to another user. */
    linkedin?: Omit<LinkedInOAuthWithMetadata, 'type'>;
    /** The user's Spotify account, if they have linked one. It cannot be linked to another user. */
    spotify?: Omit<SpotifyOAuthWithMetadata, 'type'>;
    /** The user's Instagram account, if they have linked one. It cannot be linked to another user. */
    instagram?: Omit<InstagramOAuthWithMetadata, 'type'>;
    /** The user's Custom JWT account, if they have linked one. It cannot be linked to another user. */
    custom?: Omit<CustomJwtWithMetadata, 'type'>;
    /** The user's Farcaster account, if they have linked one. It cannot be linked to another user. */
    farcaster?: Omit<FarcasterWithMetadata, 'type'>;
    /** The user's Telegram account, if they have linked one. It cannot be linked to another user. */
    telegram?: Omit<TelegramWithMetadata, 'type'>;
    /** The list of accounts associated with this user. Each account contains additional metadata
     * that may be helpful for advanced use cases. */
    linkedAccounts: Array<LinkedAccountWithMetadata>;
}
interface AppSettings {
    id?: string;
    name?: string;
    verificationKey: string;
    logoUrl?: string;
    theme?: 'System' | 'Light' | 'Dark' | string;
    accentColor?: string;
    walletAuth?: boolean;
    emailAuth?: boolean;
    smsAuth?: boolean;
    googleOAuth?: boolean;
    twitterOAuth?: boolean;
    discordOAuth?: boolean;
    githubOAuth?: boolean;
    appleOAuth?: boolean;
    linkedInOAuth?: boolean;
    tiktokOAuth?: boolean;
    disablePlusEmails?: boolean;
    allowlistEnabled: boolean;
    allowlistConfig: {
        errorTitle: string | null;
        errorDetail: string | null;
        ctaText: string | null;
        ctaLink: string | null;
    };
    termsAndConditionsUrl: string | null;
    privacyPolicyUrl: string | null;
    createdAt?: Date;
    updatedAt?: Date;
}
interface AuthTokenClaims {
    appId: string;
    issuer: string;
    issuedAt: number;
    expiration: number;
    sessionId: string;
    userId: string;
}
type AllowlistEntryType = 'email' | 'phone' | 'wallet';
interface AllowlistEntry {
    id: string;
    type: AllowlistEntryType;
    value: string;
    appId: string;
}
type AllowlistEntryInput = Pick<AllowlistEntry, 'type' | 'value'>;
/**
 * Get multiple users by email, phone number, and wallet address.
 */
type BulkParams = {
    /** Get users by email addresses. Use this for getting multiple users by email address. */
    emails?: string[];
    /** Get users by phone number. Use this for getting multiple users by phone number */
    phoneNumbers?: string[];
    /** Get users by wallet address. Use this for getting multiple users by wallet address */
    walletAddresses?: string[];
};
/** Object containing the relevant headers of an incoming webhook */
type WebhooksVerificationHeaderInput = {
    id: string;
    timestamp: string;
    signature: string;
};
type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};
type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;

interface DefaultsType {
    baseURL: string;
    timeout: number;
}
type Axios = typeof redaxios__default;
type AxiosRequestConfig = Parameters<Axios>[1];
declare class Http {
    private instance;
    private sdkVersion;
    baseURL: string;
    constructor(appId: string, appSecret: string, { baseURL, timeout }: DefaultsType);
    get<T>(path: string, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    post<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    patch<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    delete<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
}

/**
 * Helper type to insert the following fields into RPC bodies depending on how they are used:
 * - Delegated actions: adds {address: string; chainType: 'solana' | 'ethereum'}
 * - Server wallets: adds {walletId: string}
 *
 */
type WithWalletIdOrAddressChainType<T, U extends 'solana' | 'ethereum'> = Prettify<T & {
    /**
     * Address of the wallet.
     * @deprecated Use walletId instead
     */
    address: string;
    /**
     * Chain type of the wallet.
     * @deprecated Use walletId instead
     */
    chainType: U;
}> | Prettify<T & {
    /** ID of the wallet. */
    walletId: string;
}>;
/**
 * Helper to insert an idempotencyKey field into request bodies
 */
type WithOptionalIdempotencyKey<T> = Prettify<T & {
    idempotencyKey?: string;
}>;

type Hex = `0x${string}`;
type Quantity = Hex | number;
type EthereumRpcWrapper<T> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<T, 'ethereum'>>;
/**
 * CAIP-2 chain IDs for EVM networks.
 */
type EvmCaip2ChainId = `eip155:${string}`;
/**
 * Inputs for the `privy.walletApi.ethereum.signMessage(...) method.
 */
type EthereumSignMessageInputType = EthereumRpcWrapper<{
    /** Message to sign as a UTF-8 string, a hex string, or an array of bytes. */
    message: string | Uint8Array;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.signTypedData(...) method.
 */
type EthereumSignTypedDataInputType = EthereumRpcWrapper<{
    /** EIP712 typed data to sign. */
    typedData: {
        domain: Record<string, any>;
        types: Record<string, any>;
        message: Record<string, any>;
        primaryType: string;
    };
}>;
type EthereumBaseTransactionInputType = {
    transaction: {
        /** The address the transaction is sent from. Must be hexadecimal formatted. */
        from?: Hex;
        /** Destination address of the transaction. */
        to?: Hex;
        /** The nonce to be used for the transaction (hexadecimal or number). */
        nonce?: Quantity;
        /** (optional) The chain ID of network your transaction will  be sent on. */
        chainId?: Quantity;
        /** (optional) Data to send to the receiving address, especially when calling smart contracts. Must be hexadecimal formatted. */
        data?: Hex;
        /** (optional) The value (in wei) be sent with the transaction (hexadecimal or number). */
        value?: Quantity;
        /** (optional) The EIP-2718 transction type (e.g. `2` for EIP-1559 transactions). */
        type?: 0 | 1 | 2;
        /** (optional) The max units of gas that can be used by this transaction (hexadecimal or number). */
        gasLimit?: Quantity;
        /** (optional) The price (in wei) per unit of gas for this transaction (hexadecimal or number), for use in non EIP-1559 transactions (type 0 or 1). */
        gasPrice?: Quantity;
        /** (optional) The maxFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
        maxFeePerGas?: Quantity;
        /** (optional) The maxPriorityFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
        maxPriorityFeePerGas?: Quantity;
    };
};
/**
 * Inputs for the `privy.walletApi.ethereum.signTransaction(...) method.
 */
type EthereumSignTransactionInputType = EthereumRpcWrapper<EthereumBaseTransactionInputType>;
/**
 * Inputs for the `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type EthereumSendTransactionInputType = EthereumRpcWrapper<EthereumBaseTransactionInputType & {
    /** CAIP-2 chain ID for the network to broadcast the transaction on. */
    caip2: EvmCaip2ChainId;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.secp256k1Sign(...) method.
 */
type EthereumSecp256k1SignInputType = EthereumRpcWrapper<{
    /** The hash to sign. */
    hash: Hex;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.sign7702Authorization(...) method.
 */
type EthereumSign7702AuthorizationInputType = EthereumRpcWrapper<{
    /** Contract address to authorize. */
    contract: Hex;
    /** Chain id of the contract. */
    chainId: Quantity;
    /** (optional) The nonce to be used for the authorization. */
    nonce?: Quantity;
}>;
type EthereumRpcInputTypes = EthereumSignMessageInputType | EthereumSignTypedDataInputType | EthereumSignTransactionInputType | EthereumSendTransactionInputType | EthereumSecp256k1SignInputType | EthereumSign7702AuthorizationInputType;
/** Response for the `privy.walletApi.ethereum.signMessage(...) method. */
type EthereumSignMessageResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.secp256k1Sign(...) method. */
type EthereumSecp256k1SignResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.signTypedData(...) method. */
type EthereumSignTypedDataResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.signTransaction(...) method. */
type EthereumSignTransactionResponseType = {
    /** Signed transaction by the wallet. */
    signedTransaction: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.sendTransaction(...) method. */
type EthereumSendTransactionResponseType = {
    /** Hash for the broadcasted transaction. */
    hash: string;
    /** CAIP-2 chain ID for the network the transaction was broadcasted on. */
    caip2: EvmCaip2ChainId;
};
/** Response for the `privy.walletApi.ethereum.sign7702Authorization(...) method. */
type EthereumSign7702AuthorizationResponseType = {
    /** Chain id of the contract. */
    chainId: Quantity;
    /** Contract address to authorize. */
    contract: Hex;
    /** Nonce used for the authorization. */
    nonce: Quantity;
    /** Y parity of the signature. */
    yParity: number;
    /** R value of the signature. */
    r: Hex;
    /** S value of the signature. */
    s: Hex;
};

declare class EthereumRpcApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey: bigint | null;
    });
    /**
     * Method to sign a message with an Ethereum wallet using the 'personal_sign' RPC.
     *
     * @param input {EthereumSignMessageInputType} message to sign
     * @returns {EthereumSignMessageResponseType} signature and encoding of signature
     */
    signMessage(input: EthereumSignMessageInputType): Promise<EthereumSignMessageResponseType>;
    secp256k1Sign(input: EthereumSecp256k1SignInputType): Promise<EthereumSecp256k1SignResponseType>;
    /**
     * Method to sign an EIP712 typed data message with an Ethereum wallet using the
     * 'eth_signTypedData_v4' RPC.
     *
     * @param input {EthereumSignTypedData} typed data message to sign
     * @returns {EthereumSignTypedDataResponseType} signature and encoding of signature
     */
    signTypedData(input: EthereumSignTypedDataInputType): Promise<EthereumSignTypedDataResponseType>;
    /**
     * Method to sign a transaction with an Ethereum wallet using the 'eth_signTransaction' RPC.
     *
     * @param input {EthereumSignTransactionInputType} transaction to sign
     * @returns {EthereumSignTransactionResponseType} signed transaction and encoding of signature
     */
    signTransaction(input: EthereumSignTransactionInputType): Promise<EthereumSignTransactionResponseType>;
    /**
     * Method to sign and send a transaction with an Ethereum wallet using the
     * 'eth_sendTransaction' RPC.
     *
     * @param input {EthereumSendTransactionInputType} transaction to send and CAIP-2 chain ID for the transaction
     * @returns {EthereumSendTransactionResponseType} transaction hash and CAIP-2 chain ID for the transaction's network
     */
    sendTransaction(input: EthereumSendTransactionInputType): Promise<EthereumSendTransactionResponseType>;
    /**
     * Method to sign an EIP-7702 authorization with an Ethereum wallet using the
     * 'eth_sign7702Authorization' RPC.
     *
     * @param input {EthereumSign7702AuthorizationInputType} authorization to sign
     * @returns {EthereumSign7702AuthorizationResponseType} signed authorization object
     */
    sign7702Authorization(input: EthereumSign7702AuthorizationInputType): Promise<EthereumSign7702AuthorizationResponseType>;
}

/**
 * CAIP-2 chain IDs for Solana mainnet, devnet, and testnet
 *
 * - Mainnet: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
 * - Devnet: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
 * - Testnet: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'
 */
type SolanaCaip2ChainId = 
/** Solana mainnet CAIP-2 chain ID */
'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
/** Solana devnet CAIP-2 chain ID */
 | 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
/** Solana testnet CAIP-2 chain ID */
 | 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z';
type SolanaRpcWrapper<T> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<T, 'solana'>>;
/** Input for the `privy.walletApi.solana.signMessage(...)` method. */
type SolanaSignMessageInputType = SolanaRpcWrapper<{
    /** Message to sign with the wallet. */
    message: string | Uint8Array;
}>;
/** Input for the `privy.walletApi.solana.signTransaction(...)` method. */
type SolanaSignTransactionInputType = SolanaRpcWrapper<{
    /** Transaction object to sign with the wallet */
    transaction: Transaction | VersionedTransaction;
}>;
/** Input for the `privy.walletApi.solana.sendTransaction(...)` method. */
type SolanaSignAndSendTransactionInputType = SolanaRpcWrapper<{
    /** Transaction object to sign with the wallet */
    transaction: Transaction | VersionedTransaction;
    /** CAIP-2 chain ID for the Solana network to broadcast the transaction on. */
    caip2: SolanaCaip2ChainId;
}>;
type SolanaRpcInputTypes = SolanaSignMessageInputType | SolanaSignTransactionInputType | SolanaSignAndSendTransactionInputType;
/** Response  for the `privy.walletApi.solana.signMessage(...)` method. */
type SolanaSignMessageResponseType = {
    /** Signature produced by the wallet. */
    signature: Uint8Array;
};
/** Response for the `privy.walletApi.solana.signTransaction(...)` method. */
type SolanaSignTransactionResponseType = {
    /** Signed transaction object. */
    signedTransaction: Transaction | VersionedTransaction;
};
/** Response for the `privy.walletApi.solana.signAndSendTransaction(...) method. */
type SolanaSignAndSendTransactionResponseType = {
    /** Hash for the broadcasted transaction. */
    hash: string;
    /** CAIP-2 chain ID for the network the transaction was broadcasted on. */
    caip2: SolanaCaip2ChainId;
};

/**
 * @deprecated Use `SolanaSignMessageInputType` instead with the
 * `privy.walletApi.solana.signMessage(...) method.
 */
type SolanaSignMessageRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'signMessage';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** Message to sign with the wallet. */
        message: string | Uint8Array;
    };
}, 'solana'>>;
type SolanaBaseTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = {
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** transaction object to sign with the wallet */
        transaction: TTransactionType;
    };
};
/**
 * @deprecated Use `SolanaSignTransactionInputType` instead with the
 * `privy.walletApi.solana.signTransaction(...) method.
 *
 * The input parameters for the `signTransaction` RPC method to sign a Solana transaction.
 * If you use this type directly you can optionally narrow it to just `Transaction` or `VersionedTransaction`,
 * like `SolanaSignTransactionRpcInputType<VersionedTransaction>`.
 * Otherwise, the `rpc` method will determine the type of transaction you passed in and return the appropriate type.
 */
type SolanaSignTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<SolanaBaseTransactionRpcInputType<TTransactionType> & {
    /** RPC method to execute with the wallet.  */
    method: 'signTransaction';
}, 'solana'>>;
/**
 *  * @deprecated Use `SolanaSignAndSendTransactionInputType` instead with the
 * `privy.walletApi.solana.signAndSendTransaction(...) method.
 *
 * The input parameters for the `signAndSendTransaction` RPC method to sign a Solana transaction.
 * If you use this type directly you can optionally narrow it to just `Transaction` or `VersionedTransaction`,
 * like `SolanaSignAndSendTransactionRpcInputType<VersionedTransaction>`.
 * Otherwise, the `rpc` method will determine the type of transaction you passed in and return the appropriate type.
 */
type SolanaSignAndSendTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<SolanaBaseTransactionRpcInputType<TTransactionType> & {
    /** RPC method to execute with the wallet.  */
    method: 'signAndSendTransaction';
    /**
     * CAIP-2 chain ID for the Solana network to broadcast the transaction on.
     **/
    caip2: SolanaCaip2ChainId;
}, 'solana'>>;
/**
 * @deprecated Use `EthereumSignTypedDataInputType` instead with the
 * `privy.walletApi.ethereum.signTypedData(...) method.
 */
type EthereumSignTypedDataRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'eth_signTypedData_v4';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        typedData: {
            domain: Record<string, any>;
            types: Record<string, any>;
            message: Record<string, any>;
            primaryType: string;
        };
    };
}, 'ethereum'>>;
/**
 * @deprecated Use `EthereumSignMessageInputType` instead with the
 * `privy.walletApi.ethereum.signMessage(...) method.
 */
type EthereumPersonalSignRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'personal_sign';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        message: string | Uint8Array;
    };
}, 'ethereum'>>;
type EthereumBaseTransactionRpcInputType = {
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** The transaction object to sign with the wallet. */
        transaction: {
            /** The address the transaction is sent from. Must be hexadecimal formatted. */
            from?: Hex;
            /** Destination address of the transaction. */
            to?: Hex;
            /** The nonce to be used for the transaction (hexadecimal or number). */
            nonce?: Quantity;
            /** (optional) The chain ID of network your transaction will  be sent on. */
            chainId?: Quantity;
            /** (optional) Data to send to the receiving address, especially when calling smart contracts. Must be hexadecimal formatted. */
            data?: Hex;
            /** (optional) The value (in wei) be sent with the transaction (hexadecimal or number). */
            value?: Quantity;
            /** (optional) The EIP-2718 transction type (e.g. `2` for EIP-1559 transactions). */
            type?: 0 | 1 | 2;
            /** (optional) The max units of gas that can be used by this transaction (hexadecimal or number). */
            gasLimit?: Quantity;
            /** (optional) The price (in wei) per unit of gas for this transaction (hexadecimal or number), for use in non EIP-1559 transactions (type 0 or 1). */
            gasPrice?: Quantity;
            /** (optional) The maxFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
            maxFeePerGas?: Quantity;
            /** (optional) The maxPriorityFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
            maxPriorityFeePerGas?: Quantity;
        };
    };
};
/**
 * @deprecated Use `EthereumSignTransactionInputType` instead with the
 * `privy.walletApi.ethereum.signTransaction(...) method.
 */
type EthereumSignTransactionRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<EthereumBaseTransactionRpcInputType & {
    /** RPC method to execute with the wallet.  */
    method: 'eth_signTransaction';
}, 'ethereum'>>;
/**
 * @deprecated Use `EthereumSendTransactionInputType` instead with the
 * `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type EthereumSendTransactionRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<EthereumBaseTransactionRpcInputType & {
    /** RPC method to execute with the wallet.  */
    method: 'eth_sendTransaction';
    /** CAIP-2 chain ID for the EVM network to broadcast the transaction on. */
    caip2: EvmCaip2ChainId;
}, 'ethereum'>>;
type WalletApiRpcInputType = SolanaSignMessageRpcInputType | SolanaSignTransactionRpcInputType | SolanaSignAndSendTransactionRpcInputType | EthereumSignTypedDataRpcInputType | EthereumPersonalSignRpcInputType | EthereumSignTransactionRpcInputType | EthereumSendTransactionRpcInputType;
/**
 * @deprecated Use `SolanaSignTransactionResponseType` instead from the
 * `privy.walletApi.solana.signTransaction(...) method.
 */
type WalletApiSolanaSignTransactionRpcResponseType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = {
    /** RPC method executed by the wallet. */
    method: 'signTransaction';
    /** Data returned from the RPC method. */
    data: {
        /** Signed transaction object produced by the wallet. */
        signedTransaction: TTransactionType;
    };
};
/**
 * @deprecated Use `SolanaSignAndSendTransactionResponseType` instead from the
 * `privy.walletApi.solana.signAndSendTransaction(...) method.
 */
type WalletApiSolanaSignAndSendTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'signAndSendTransaction';
} & ({
    /** Data returned from the RPC method. */
    data: {
        /** A Privy-assigned id for the sent transaction. */
        transactionId?: string;
        /** Transaction hash. */
        hash: string;
        /** CAIP-2 chain ID of the Solana network the transaction was broadcasted on. */
        caip2: SolanaCaip2ChainId;
    };
} | {
    error: {
        /** Error code. */
        code: string;
        /** Error message. */
        message: string;
    };
});
/**
 * @deprecated Use `SolanaSignMessageResponseType` instead from the
 * `privy.walletApi.solana.signMessage(...) method.
 */
type WalletApiSolanaSignMessageRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'signMessage';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: Uint8Array;
    };
};
/**
 * @deprecated Use `EthereumSignTypedDataResponseType` instead from the
 * `privy.walletApi.ethereum.signTypedData(...) method.
 */
type WalletApiEthereumSignTypedDataRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_signTypedData_v4';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: string;
        /** Encoding of the signature. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSignMessageResponseType` instead from the
 * `privy.walletApi.ethereum.signMessage(...) method.
 */
type WalletApiEthereumPersonalSignRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'personal_sign';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: string;
        /** Encoding of the signature. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSignTransactionResponseType` instead from the
 * `privy.walletApi.ethereum.signTransaction(...) method.
 */
type WalletApiEthereumSignTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_signTransaction';
    /** Data returned from the RPC method. */
    data: {
        /** Signed transaction object produced by the wallet. */
        signedTransaction: string;
        /** Encoding of the signed transaction. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSendTransactionResponseType` instead from the
 * `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type WalletApiEthereumSendTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_sendTransaction';
} & ({
    /** Data returned from the RPC method. */
    data: {
        /** A Privy-assigned id for the sent transaction. */
        transactionId?: string;
        /** Transaction hash. */
        hash: string;
        /** CAIP-2 chain ID of the EVM network the transaction was broadcasted on. */
        caip2: EvmCaip2ChainId;
    };
} | {
    error: {
        /** Error code. */
        code: string;
        /** Error message. */
        message: string;
    };
});
type WalletApiRpcResponseType = WalletApiSolanaSignTransactionRpcResponseType | WalletApiSolanaSignMessageRpcResponseType | WalletApiSolanaSignAndSendTransactionRpcResponseType | WalletApiEthereumSignTypedDataRpcResponseType | WalletApiEthereumPersonalSignRpcResponseType | WalletApiEthereumSignTransactionRpcResponseType | WalletApiEthereumSendTransactionRpcResponseType;

type BaseWalletCreateInput = {
    /** Chain type for the created wallet. */
    chainType: ChainType;
};
type SignersInput = XOR<{
    authorizationKeyIds?: string[];
    authorizationThreshold?: number;
}, {
    /** Optional signers for transacting with the wallet. If signers are specified, RPC requests against the wallet must be signed */
    additionalSigners?: {
        /** The ID of the Key Quorum to use for the signer */
        signerId: string;
    }[];
}>;
type OwnerObject = {
    owner?: XOR<{
        /** The user ID of the owner */
        userId: string;
    }, {
        /** The public key of the owner */
        publicKey: string;
    }>;
};
type OwnerIdInput = {
    /** The ID of the Key Quorum to use for the owner */
    ownerId?: string;
};
type OwnerInput = XOR<OwnerObject, OwnerIdInput>;
type WalletApiCreateRequestType = WithOptionalIdempotencyKey<BaseWalletCreateInput & OwnerInput & SignersInput>;
type WalletApiRpcInputTypes = EthereumRpcInputTypes | SolanaRpcInputTypes;
type WalletApiWalletResponseType = {
    /** Unique ID for the created wallet. Used to take actions with the wallet after creation. */
    id: string;
    /** Chain type for the created wallet. */
    chainType: ChainType;
    /** Address for the created wallet */
    address: string;
    /** Policy IDs that have been assigned to the wallet. */
    policyIds: string[];
    /** The creation date of the wallet */
    createdAt: Date;
};
type WalletApiFindWalletsRequestType = {
    /** Cursor used to paginate results */
    cursor?: string;
    /** Maximum results per page */
    limit?: number;
    /** Chain type to filter by. */
    chainType?: ChainType;
};
type WalletApiFindWalletsResponseType = {
    /** List of wallets */
    data: Array<WalletApiWalletResponseType>;
    /** Cursor for the next page */
    nextCursor?: string;
};
type WalletApiTransactionResponseType = {
    /** Unique ID for the transaction */
    id: string;
    /** Wallet ID for the transaction */
    walletId: string;
    /** CAIP2 for the transaction */
    caip2: string;
    /** Transaction hash for the transaction */
    transactionHash: string | null;
    /** Status of the transaction */
    status: 'broadcasted' | 'confirmed' | 'delayed' | 'execution_reverted' | 'failed';
};
type PolicyMethod = 'eth_signTransaction' | 'eth_sendTransaction' | 'eth_signTypedData_v4' | 'eth_sign7702Authorization' | 'signAndSendTransaction' | 'signTransaction' | 'exportPrivateKey' | '*';
type PolicyRuleConditionOperator = 'eq' | 'gt' | 'gte' | 'lt' | 'lte' | 'in';
type WalletApiPolicyResponseType = {
    /** Unique ID for the policy */
    id: string;
    /** Name of the policy */
    name: string;
    /** Version of the policy */
    version: '1.0';
    /** Chain type of the policy */
    chainType: ChainType;
    /** Rules of the policy per RPC method */
    rules: WalletApiPolicyRuleType[];
    /** Creation date of the policy */
    createdAt: Date;
};
type WalletApiPolicyOwnerInput = XOR<{
    /** The ID of the Key Quorum to use for the owner */
    ownerId?: string;
}, {
    owner?: {
        /** The public key of the owner */
        publicKey: string;
    };
}>;
type WalletApiPolicyCreateRequestType = {
    /** Name of the policy */
    name: string;
    /** Version of the policy */
    version: '1.0';
    /** Chain type of the policy */
    chainType: 'ethereum';
    /** Rules of the policy per RPC method */
    rules: WalletApiPolicyRuleType[];
} & WalletApiPolicyOwnerInput;
type WalletApiPolicyUpdateRequestType = {
    /** ID of the policy */
    id: string;
    /** Name of the policy */
    name?: string;
    /** Rules of the policy per RPC method */
    rules?: WalletApiPolicyRuleType[];
};
type WalletApiPolicyDeleteRequestType = {
    /** ID of the policy */
    id: string;
};
type WalletApiPolicyRuleType = {
    id: string;
    name: string;
    action: PolicyActionType;
    method: PolicyMethod;
    conditions: WalletApiPolicyRuleConditionType[];
};
type WalletApiPolicyRuleCreateRequestType = {
    /** ID of the policy */
    policyId: string;
    /** Name of the rule */
    name: string;
    /** Action of the rule */
    action: PolicyActionType;
    /** Method of the rule */
    method: PolicyMethod;
    /** Conditions of the rule */
    conditions: WalletApiPolicyRuleConditionType[];
};
type WalletApiPolicyRuleUpdateRequestType = WalletApiPolicyRuleCreateRequestType & {
    /** ID of the rule */
    ruleId: string;
};
type WalletApiPolicyRuleDeleteRequestType = {
    /** ID of the policy */
    policyId: string;
    /** ID of the rule */
    ruleId: string;
};
type WalletApiPolicyRuleGetRequestType = WalletApiPolicyRuleDeleteRequestType;
type WalletApiPolicyRuleConditionType = WalletApiPolicyEthereumTransactionCondition | WalletApiPolicyEthereumCalldataCondition | WalletApiPolicyEthereumTypedDataDomainCondition | WalletApiPolicyEthereumTypedDataMessageCondition | WalletApiPolicyEthereum7702AuthorizationCondition | WalletApiPolicySolanaProgramInstructionCondition | WalletApiPolicySolanaSystemProgramInstructionCondition | WalletApiPolicySolanaTokenProgramInstructionCondition;
type WalletApiPolicyEthereumTransactionCondition = {
    fieldSource: 'ethereum_transaction';
    field: 'to' | 'value';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicyEthereumCalldataCondition = {
    fieldSource: 'ethereum_calldata';
    field: string;
    operator: PolicyRuleConditionOperator;
    value: string | string[];
    abi: any;
};
type WalletApiPolicyEthereumTypedDataDomainCondition = {
    fieldSource: 'ethereum_typed_data_domain';
    field: 'chain_id' | 'verifying_contract' | 'chainId' | 'verifyingContract';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicyEthereumTypedDataMessageCondition = {
    fieldSource: 'ethereum_typed_data_message';
    field: string;
    operator: PolicyRuleConditionOperator;
    value: string | string[];
    typedData: {
        types: Record<string, Array<{
            name: string;
            type: string;
        }>>;
        primaryType: string;
    };
};
type WalletApiPolicyEthereum7702AuthorizationCondition = {
    fieldSource: 'ethereum_7702_authorization';
    field: 'contract';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicySolanaProgramInstructionCondition = {
    fieldSource: 'solana_program_instruction';
    field: 'programId';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicySolanaSystemProgramInstructionCondition = {
    fieldSource: 'solana_system_program_instruction';
    field: 'instructionName' | 'Transfer.lamports' | 'Transfer.to' | 'Transfer.from';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicySolanaTokenProgramInstructionCondition = {
    fieldSource: 'solana_token_program_instruction';
    field: 'instructionName' | 'TransferChecked.source' | 'TransferChecked.destination' | 'TransferChecked.authority' | 'TransferChecked.amount' | 'TransferChecked.mint';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiRequestSignatureInput = {
    /** Signature version. 1 is currently the only valid version. */
    version: 1;
    /** Request method. Signatures are not required on 'GET' requests. */
    method: 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    /** URL for the request. Should not contain a trailing slash. */
    url: string;
    /** Request body. */
    body: any;
    /** Privy-specific headers. */
    headers: {
        'privy-app-id': string;
        'privy-idempotency-key'?: string;
    };
};
type WalletApiGenerateUserSignerResponseType = {
    /** The decrypted authorization key */
    authorizationKey: string;
    /** The expiration timestamp of the authorization key */
    expiresAt: Date;
    /** The wallets that this authorization key can be used for */
    wallets: Array<WalletApiWalletResponseType>;
};

declare class SolanaRpcApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey: bigint | null;
    });
    /**
     * Method to sign a message with an Solana wallet using the 'signMessage' RPC.
     *
     * @param input {SolanaSignMessageInputType} message to sign
     * @returns {SolanaSignMessageResponseType} signature and encoding of signature
     */
    signMessage(input: SolanaSignMessageInputType): Promise<SolanaSignMessageResponseType>;
    /**
     * Method to sign a transaction with an Solana wallet using the 'signTransaction' RPC.
     *
     * @param input {SolanaSignTransactionInputType} transaction to sign
     * @returns {SolanaSignTransactionResponseType} signed transaction
     */
    signTransaction(input: SolanaSignTransactionInputType): Promise<{
        signedTransaction: _solana_web3_js.Transaction | _solana_web3_js.VersionedTransaction;
    }>;
    /**
     * Method to sign and send a transaction with an Solana wallet using the 'signAndSendTransaction' RPC.
     *
     * @param input {SolanaSignAndSendTransactionType} transaction to sign and broadcast
     * @returns {SolanaSignAndSendTransactionResponseType} transaction hash
     */
    signAndSendTransaction(input: SolanaSignAndSendTransactionInputType): Promise<{
        hash: string;
        caip2: SolanaCaip2ChainId;
    }>;
}

/**
 * Class to support making RPC requests to the Privy wallets API. When the Privy client
 * is constructed, this class is also constructed and will be set as the `.walletApi` field
 * for the client.
 */
declare class WalletApi {
    #private;
    private appId;
    private api;
    private authorizationPrivateKey;
    ethereum: EthereumRpcApi;
    solana: SolanaRpcApi;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey?: string;
    });
    getWallets(input?: WalletApiFindWalletsRequestType): Promise<WalletApiFindWalletsResponseType>;
    getWallet({ id, }: {
        /** ID for the wallet to fetch. */
        id: string;
    }): Promise<WalletApiWalletResponseType>;
    /**
     * Updates the authorization key used for signing requests to the Privy Wallets API.
     *
     * @param authorizationPrivateKey The new authorization private key to use for signing requests.
     */
    updateAuthorizationKey(authorizationPrivateKey: string): void;
    /**
     * Generates a user signer for the given user JWT.
     *
     * The user signer can then be used to securely sign API requests
     * on behalf of the user.
     *
     * @param userJwt - The user JWT to generate the user signer.
     * @returns {WalletApiGenerateUserSignerResponseType} - The generated user signer containing the authorization key, expiration date, and associated wallets.
     */
    generateUserSigner({ userJwt, }: {
        /** User JWT to generate the user signer */
        userJwt: string;
    }): Promise<WalletApiGenerateUserSignerResponseType>;
    getPolicy({ id }: {
        id: string;
    }): Promise<WalletApiPolicyResponseType>;
    createPolicy(input: WalletApiPolicyCreateRequestType): Promise<WalletApiPolicyResponseType>;
    updatePolicy(input: WalletApiPolicyUpdateRequestType): Promise<WalletApiPolicyResponseType>;
    deletePolicy(input: WalletApiPolicyDeleteRequestType): Promise<void>;
    addRuleToPolicy(input: WalletApiPolicyRuleCreateRequestType): Promise<WalletApiPolicyRuleType>;
    updateRuleInPolicy(input: WalletApiPolicyRuleUpdateRequestType): Promise<WalletApiPolicyRuleType>;
    deleteRuleFromPolicy(input: WalletApiPolicyRuleDeleteRequestType): Promise<void>;
    getRuleInPolicy(input: WalletApiPolicyRuleGetRequestType): Promise<WalletApiPolicyRuleType>;
    getTransaction({ id }: {
        id: string;
    }): Promise<WalletApiTransactionResponseType>;
    /**
     * @deprecated This is deprecated in favor of createWallet
     */
    create(input: WalletApiCreateRequestType): Promise<WalletApiWalletResponseType>;
    /**
     * Create a new Ethereum or Solana wallet
     * @param input @type {WalletApiCreateRequestType}
     * @returns @type {WalletApiWalletResponseType}
     */
    createWallet(input: WalletApiCreateRequestType): Promise<WalletApiWalletResponseType>;
    /**
     * @deprecated Use specific methods on the `privy.walletApi.ethereum` and `privy.walletApi.solana` classes instead:
     * - `privy.walletApi.ethereum.{signMessage, signTypedData, signTransaction, sendTransaction}`
     * - `privy.walletApi.solana.{signMessage, signTransaction, signAndSendTransaction}`
     *
     * Executed RPC requests for the provided wallet.
     *
     * @returns data returned by executed RPC method
     */
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType<Transaction>): Promise<WalletApiSolanaSignTransactionRpcResponseType<Transaction>>;
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType<VersionedTransaction>): Promise<WalletApiSolanaSignTransactionRpcResponseType<VersionedTransaction>>;
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType): Promise<WalletApiSolanaSignTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType<Transaction>): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType<VersionedTransaction>): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signMessage';
    } & SolanaSignMessageRpcInputType): Promise<WalletApiSolanaSignMessageRpcResponseType>;
    rpc(input: {
        method: 'eth_signTransaction';
    } & EthereumSignTransactionRpcInputType): Promise<WalletApiEthereumSignTransactionRpcResponseType>;
    rpc(input: {
        method: 'personal_sign';
    } & EthereumPersonalSignRpcInputType): Promise<WalletApiEthereumPersonalSignRpcResponseType>;
    rpc(input: {
        method: 'eth_signTypedData_v4';
    } & EthereumSignTypedDataRpcInputType): Promise<WalletApiEthereumSignTypedDataRpcResponseType>;
    rpc(input: {
        method: 'eth_sendTransaction';
    } & EthereumSendTransactionRpcInputType): Promise<WalletApiEthereumSendTransactionRpcResponseType>;
}
/**
 * Generates an authorization signature for a given wallet API request.
 *
 * Use this signature in the `privy-authorization-signature` header to authorize your request.
 *
 * Typically, it is not required to call this manually, as providing an `authorizationPrivateKey` to the `WalletAPI` class
 * at instantiation will automatically sign and populate this header for all requisite RPC requests.
 * Manual signing of requests is intended for advanced use cases.
 *
 * @param input - The request payload to sign which should match the input of the WalletAPI method to be called.
 * @param authorizationPrivateKey - The authorization key used to sign the request.
 * @returns The signature of the request payload which should be used in the `privy-authorization-signature` header.
 */
declare function generateAuthorizationSignature({ input, authorizationPrivateKey, }: {
    input: WalletApiRequestSignatureInput;
    authorizationPrivateKey: string;
}): string | undefined;
/**
 * Formats and serializes a request payload that can be used to generate an authorization signature.
 * This function typically should not need to be called directly, except for advanced use cases.
 *
 * @param input - The request payload to format which should match the input of the WalletAPI method to be called.
 * @returns The formatted request payload which can be used to generate an authorization signature.
 */
declare function formatRequestForAuthorizationSignature({ input, }: {
    input: WalletApiRequestSignatureInput;
}): Buffer;

export { type WalletApiPolicyDeleteRequestType as $, type AppSettings as A, type BulkParams as B, type CreateWalletInput as C, type Discord as D, type Email as E, type Farcaster as F, type Google as G, type Hex as H, type ImportUserInput as I, type LinkedAccountWithMetadata as J, type WalletApiCreateRequestType as K, type LinkedIn as L, type WalletApiRpcInputTypes as M, type WalletApiWalletResponseType as N, type WalletApiFindWalletsRequestType as O, type Phone as P, type WalletApiFindWalletsResponseType as Q, type WalletApiTransactionResponseType as R, type Spotify as S, type Twitter as T, type User as U, type PolicyMethod as V, WalletApi as W, type PolicyRuleConditionOperator as X, type WalletApiPolicyResponseType as Y, type WalletApiPolicyCreateRequestType as Z, type WalletApiPolicyUpdateRequestType as _, type AllowlistEntry as a, type WalletApiPolicyRuleType as a0, type WalletApiPolicyRuleCreateRequestType as a1, type WalletApiPolicyRuleUpdateRequestType as a2, type WalletApiPolicyRuleDeleteRequestType as a3, type WalletApiPolicyRuleGetRequestType as a4, type WalletApiPolicyRuleConditionType as a5, type WalletApiPolicyEthereumTransactionCondition as a6, type WalletApiPolicyEthereumCalldataCondition as a7, type WalletApiPolicyEthereumTypedDataDomainCondition as a8, type WalletApiPolicyEthereumTypedDataMessageCondition as a9, type SolanaSignMessageResponseType as aA, type SolanaSignTransactionResponseType as aB, type SolanaSignAndSendTransactionResponseType as aC, type SolanaSignMessageRpcInputType as aD, type SolanaSignTransactionRpcInputType as aE, type SolanaSignAndSendTransactionRpcInputType as aF, type EthereumSignTypedDataRpcInputType as aG, type EthereumPersonalSignRpcInputType as aH, type EthereumSignTransactionRpcInputType as aI, type EthereumSendTransactionRpcInputType as aJ, type WalletApiRpcInputType as aK, type WalletApiSolanaSignTransactionRpcResponseType as aL, type WalletApiSolanaSignAndSendTransactionRpcResponseType as aM, type WalletApiSolanaSignMessageRpcResponseType as aN, type WalletApiEthereumSignTypedDataRpcResponseType as aO, type WalletApiEthereumPersonalSignRpcResponseType as aP, type WalletApiEthereumSignTransactionRpcResponseType as aQ, type WalletApiEthereumSendTransactionRpcResponseType as aR, type WalletApiRpcResponseType as aS, generateAuthorizationSignature as aT, formatRequestForAuthorizationSignature as aU, type WalletApiPolicyEthereum7702AuthorizationCondition as aa, type WalletApiPolicySolanaProgramInstructionCondition as ab, type WalletApiPolicySolanaSystemProgramInstructionCondition as ac, type WalletApiPolicySolanaTokenProgramInstructionCondition as ad, type WalletApiRequestSignatureInput as ae, type WalletApiGenerateUserSignerResponseType as af, type Quantity as ag, type EvmCaip2ChainId as ah, type EthereumSignMessageInputType as ai, type EthereumSignTypedDataInputType as aj, type EthereumSignTransactionInputType as ak, type EthereumSendTransactionInputType as al, type EthereumSecp256k1SignInputType as am, type EthereumSign7702AuthorizationInputType as an, type EthereumRpcInputTypes as ao, type EthereumSignMessageResponseType as ap, type EthereumSecp256k1SignResponseType as aq, type EthereumSignTypedDataResponseType as ar, type EthereumSignTransactionResponseType as as, type EthereumSendTransactionResponseType as at, type EthereumSign7702AuthorizationResponseType as au, type SolanaCaip2ChainId as av, type SolanaSignMessageInputType as aw, type SolanaSignTransactionInputType as ax, type SolanaSignAndSendTransactionInputType as ay, type SolanaRpcInputTypes as az, type AllowlistEntryInput as b, type AuthTokenClaims as c, type WebhooksVerificationHeaderInput as d, type EmailWithMetadata as e, type PhoneWithMetadata as f, type Wallet as g, type WalletWithMetadata as h, type GoogleOAuthWithMetadata as i, type TwitterOAuthWithMetadata as j, type DiscordOAuthWithMetadata as k, type Github as l, type GithubOAuthWithMetadata as m, type Apple as n, type AppleOAuthWithMetadata as o, type LinkedInOAuthWithMetadata as p, type Tiktok as q, type TiktokOAuthWithMetadata as r, type SpotifyOAuthWithMetadata as s, type Instagram as t, type InstagramOAuthWithMetadata as u, type Telegram as v, type TelegramWithMetadata as w, type FarcasterWithMetadata as x, type CustomJwt as y, type CustomJwtWithMetadata as z };
