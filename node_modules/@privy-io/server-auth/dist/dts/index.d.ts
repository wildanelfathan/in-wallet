import { W as WalletApi, U as User, B as BulkParams, I as ImportUserInput, C as CreateWalletInput, A as AppSettings, a as AllowlistEntry, b as AllowlistEntryInput, c as AuthTokenClaims, d as WebhooksVerificationHeaderInput } from './public-DND8niKQ.js';
export { n as Apple, o as AppleOAuthWithMetadata, y as CustomJwt, z as CustomJwtWithMetadata, D as Discord, k as DiscordOAuthWithMetadata, E as Email, e as EmailWithMetadata, aH as EthereumPersonalSignRpcInputType, ao as EthereumRpcInputTypes, am as EthereumSecp256k1SignInputType, aq as EthereumSecp256k1SignResponseType, al as EthereumSendTransactionInputType, at as EthereumSendTransactionResponseType, aJ as EthereumSendTransactionRpcInputType, an as EthereumSign7702AuthorizationInputType, au as EthereumSign7702AuthorizationResponseType, ai as EthereumSignMessageInputType, ap as EthereumSignMessageResponseType, ak as EthereumSignTransactionInputType, as as EthereumSignTransactionResponseType, aI as EthereumSignTransactionRpcInputType, aj as EthereumSignTypedDataInputType, ar as EthereumSignTypedDataResponseType, aG as EthereumSignTypedDataRpcInputType, ah as EvmCaip2ChainId, F as Farcaster, x as FarcasterWithMetadata, l as Github, m as GithubOAuthWithMetadata, G as Google, i as GoogleOAuthWithMetadata, H as Hex, t as Instagram, u as InstagramOAuthWithMetadata, J as LinkedAccountWithMetadata, L as LinkedIn, p as LinkedInOAuthWithMetadata, P as Phone, f as PhoneWithMetadata, V as PolicyMethod, X as PolicyRuleConditionOperator, ag as Quantity, av as SolanaCaip2ChainId, az as SolanaRpcInputTypes, ay as SolanaSignAndSendTransactionInputType, aC as SolanaSignAndSendTransactionResponseType, aF as SolanaSignAndSendTransactionRpcInputType, aw as SolanaSignMessageInputType, aA as SolanaSignMessageResponseType, aD as SolanaSignMessageRpcInputType, ax as SolanaSignTransactionInputType, aB as SolanaSignTransactionResponseType, aE as SolanaSignTransactionRpcInputType, S as Spotify, s as SpotifyOAuthWithMetadata, v as Telegram, w as TelegramWithMetadata, q as Tiktok, r as TiktokOAuthWithMetadata, T as Twitter, j as TwitterOAuthWithMetadata, g as Wallet, K as WalletApiCreateRequestType, aP as WalletApiEthereumPersonalSignRpcResponseType, aR as WalletApiEthereumSendTransactionRpcResponseType, aQ as WalletApiEthereumSignTransactionRpcResponseType, aO as WalletApiEthereumSignTypedDataRpcResponseType, O as WalletApiFindWalletsRequestType, Q as WalletApiFindWalletsResponseType, af as WalletApiGenerateUserSignerResponseType, Z as WalletApiPolicyCreateRequestType, $ as WalletApiPolicyDeleteRequestType, aa as WalletApiPolicyEthereum7702AuthorizationCondition, a7 as WalletApiPolicyEthereumCalldataCondition, a6 as WalletApiPolicyEthereumTransactionCondition, a8 as WalletApiPolicyEthereumTypedDataDomainCondition, a9 as WalletApiPolicyEthereumTypedDataMessageCondition, Y as WalletApiPolicyResponseType, a5 as WalletApiPolicyRuleConditionType, a1 as WalletApiPolicyRuleCreateRequestType, a3 as WalletApiPolicyRuleDeleteRequestType, a4 as WalletApiPolicyRuleGetRequestType, a0 as WalletApiPolicyRuleType, a2 as WalletApiPolicyRuleUpdateRequestType, ab as WalletApiPolicySolanaProgramInstructionCondition, ac as WalletApiPolicySolanaSystemProgramInstructionCondition, ad as WalletApiPolicySolanaTokenProgramInstructionCondition, _ as WalletApiPolicyUpdateRequestType, ae as WalletApiRequestSignatureInput, aK as WalletApiRpcInputType, M as WalletApiRpcInputTypes, aS as WalletApiRpcResponseType, aM as WalletApiSolanaSignAndSendTransactionRpcResponseType, aN as WalletApiSolanaSignMessageRpcResponseType, aL as WalletApiSolanaSignTransactionRpcResponseType, R as WalletApiTransactionResponseType, N as WalletApiWalletResponseType, h as WalletWithMetadata } from './public-DND8niKQ.js';
import '@solana/web3.js';
import 'redaxios';
import '@privy-io/public-api';

/**
 * The Privy client performs operations against the Privy API.
 *
 * ```typescript
 * import {PrivyClient} from '@privy-io/server-auth';
 * ```
 */
declare class PrivyClient {
    private api;
    private appId;
    private verificationKey;
    walletApi: WalletApi;
    /**
     * Creates a new Privy client.
     *
     * @param appId The app id from your console.
     * @param appSecret The app secret, only visible once on app creation in the console.
     * @param options Initialization options.
     */
    constructor(appId: string, appSecret: string, options?: {
        /**
         * The URL of the Privy API. Defaults to `https://auth.privy.io`.
         */
        apiURL?: string;
        /**
         * Time in milliseconds after which to timeout requests to the API. Defaults to `10000` (10 seconds).
         */
        timeout?: number;
        /**
         * Configuration for Privy's wallet API.
         */
        walletApi?: {
            /**
             * Private key for your app's authorization keypair.
             *
             * If your app has an authorization keypair registered in the Privy
             * Dashboard, you must pass the corresponding private key here, otherwise
             * wallet RPC requests will fail.
             */
            authorizationPrivateKey?: string;
            /**
             * The URL of the wallets API. Defaults to `https://api.privy.io`.
             */
            apiURL?: string;
        };
    });
    /**
     * Gets a user from the identity token. First, this verifies the token is valid and then parses
     * the payload into a `User` object. Note the user object may be incomplete due to identity token
     * size constraints
     *
     * ```typescript
     * const idToken = req.cookies.get('privy-id-token'); // or however your framework surfaces cookies
     * const user = await client.getUser({idToken});
     * ```
     *
     * @param props.idToken the identity token set as a cookie on the users browser
     * @returns the user object with parsed from the ID token
     */
    getUser(props: {
        idToken: string;
    }): Promise<User>;
    /**
     * @deprecated This method is subject to strict rate limits. Please use getUser({idToken: string}) to avoid rate limits as your app scales.
     *
     * Get the user object associated with the given user DID (decentralized ID).
     *
     * @param userId The Privy DID of the user.
     * @returns A {@link User} if the user exists.
     */
    getUser(userId: string): Promise<User>;
    /**
     * ATTENTION: This method is subject to strict rate limits. Please use getUser({idToken: string}) to avoid rate limits as your app scales.
     */
    getUserById(userId: string): Promise<User>;
    /**
     * Get the user object associated with an email address.
     *
     * ```typescript
     * const user = await client.getUserByEmail(emailAddress);
     * ```
     *
     * @param address The email address of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserByEmail(address: string): Promise<User | null>;
    /**
     * Get the user object associated with a phone number.
     *
     * ```typescript
     * const user = await client.getUserByPhoneNumber(number);
     * ```
     *
     * @param number The phone number of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserByPhoneNumber(number: string): Promise<User | null>;
    /**
     * Get the user object associated with a wallet address.
     *
     * ```typescript
     * const user = await client.getUserByWalletAddress(walletAddress);
     * ```
     *
     * @param walletAddress The wallet address of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserByWalletAddress(walletAddress: string): Promise<User | null>;
    /**
     * Get the user object associated with a smart wallet address.
     *
     * ```typescript
     * const user = await client.getUserBySmartWalletAddress(walletAddress);
     * ```
     *
     * @param walletAddress The smart wallet address of the user to find.
     * @returns A {@link User} if the user exists.
     */
    getUserBySmartWalletAddress(walletAddress: string): Promise<User | null>;
    /**
     * Get the user object associated with a farcaster ID.
     *
     * ```typescript
     * const user = await client.getUserByFarcasterId(fid);
     * ```
     *
     * @param fid The farcaster ID (a number).
     * @returns A {@link User} if the user exists.
     */
    getUserByFarcasterId(fid: number): Promise<User | null>;
    /**
     * Get the user object associated with a Discord username.
     *
     * ```typescript
     * const user = await client.getUserByDiscordUsername(username);
     * ```
     *
     * @param username Discord username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByDiscordUsername(username: string): Promise<User | null>;
    /**
     * Get the user object associated with a Github username.
     *
     * ```typescript
     * const user = await client.getUserByGithubUsername(username);
     * ```
     *
     * @param username Github username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByGithubUsername(username: string): Promise<User | null>;
    /**
     * Get the user object associated with a twitter username.
     *
     * ```typescript
     * const user = await client.getUserByTwitterUsername(username);
     * ```
     *
     * @param username Twitter username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTwitterUsername(username: string): Promise<User | null>;
    /**
     *
     * Get the user object associated with a twitter oauth subject (ID).
     * ```typescript
     * const user = await client.getUserByTwitterSubject(subject);
     * ```
     *
     * @param subject Twitter subject to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTwitterSubject(subject: string): Promise<User | null>;
    /**
     * Get the user object associated with a telegram user ID.
     * ```typescript
     * const user = await client.getUserByTelegramUserId(telegramUserId);
     * ```
     *
     * @param telegramUserId Telegram user ID to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTelegramUserId(telegramUserId: string): Promise<User | null>;
    /**
     * Get the user object associated with a telegram username.
     * ```typescript
     * const user = await client.getUserByTelegramUsername(telegramUsername);
     * ```
     * @param username Telegram username to search for
     * @returns A {@link User} if the user exists.
     */
    getUserByTelegramUsername(username: string): Promise<User | null>;
    /**
     * Gets a user object by their custom JWT auth ID, which
     * is scoped to an individual app.
     *
     * ```typescript
     * const user = await client.getUserByCustomAuthId(customUserId);
     * ```
     *
     * @param customUserId The custom identifier of the user defined by their JWT
     * @returns A {@link User} if the user exists.
     */
    getUserByCustomAuthId(customUserId: string): Promise<User | null>;
    /**
     * Get the list of users associated with this app.
     *
     * ```typescript
     * const users = await client.getUsers();
     * ```
     *
     * @returns A list of users.
     */
    getUsers(): Promise<Array<User>>;
    /**
     * Get the list of users associated with this app whose email,
     * phone number, wallet address, name, or username match a search term.
     *
     * ```typescript
     * const users = await client.getUsers("@privy.io");
     * ```
     *
     * @param searchTerm (optional) The value used to search the list of users.
     * @returns A list of users.
     *
     * @deprecated Use custom helper functions to search
     */
    getUsers(searchTerm: string): Promise<Array<User>>;
    /**
     * Get multiple users associated with this app by email, phone number, and wallet address
     *
     * ```typescript
     * const users = await client.getUsers({
     *     emails: ["user1@privy.io", "user2@privy.io"]
     * });
     * ```
     *
     * @param bulkParams The values used to search the list of users.
     * @returns A list of users.
     */
    getUsers(bulkParams: BulkParams): Promise<Array<User>>;
    /**
     * Delete the user object associated with the given user DID (decentralized ID).
     *
     * ```typescript
     * const user = await client.deleteUser("did:privy:XXXXX");
     * ```
     *
     * @param userId The Privy DID of the user.
     */
    deleteUser(userId: string): Promise<void>;
    /**
     * Import existing user data into Privy, including their linked account data.
     *
     * This allows your users to interact with all their linked accounts normally after your migration to Privy.
     *
     * ```typescript
     * const user = await client.importUser({
     *  createEthereumWallet: false,
     *  createSolanaWallet: false,
     *  createEthereumSmartWallet: false,
     *  linkedAccounts: [
     *    {
     *      "subject": "123456789123456789",
     *      "username": "batman#1234",
     *      "email": "batman@gmail.com",
     *      "type": "discord_oauth"
     *    },
     *    {
     *      "number": "+1 123 456 7890",
     *      "type": "phone"
     *    },
     *    {
     *      "address": "0x3DAF84b3f09A0E2092302F7560888dBc0952b7B7",
     *      "type": "wallet",
     *      "chainType": "ethereum"
     *    }
     * ]);
     * ```
     *
     * @param importUserInput The user object {@link ImportUserInput}, containing linked accounts to import.
     * @returns The resultant user {@link User} object.
     */
    importUser({ linkedAccounts, createEthereumWallet, createSolanaWallet, createEthereumSmartWallet, customMetadata, createEmbeddedWallet, wallets, }: ImportUserInput): Promise<User>;
    /**
     * Create embedded and smart wallets for an existing user on Privy.
     *
     * ```typescript
     * const user = await client.createWallets({
     *  createEthereumWallet: true,
     *  createSolanaWallet: false,
     *  createEthereumSmartWallet: true,
     *  numberOfEthereumWalletsToCreate: 2
     * });
     * ```
     */
    createWallets({ userId, createEthereumWallet, createSolanaWallet, createEthereumSmartWallet, numberOfEthereumWalletsToCreate, wallets, }: CreateWalletInput): Promise<User>;
    /**
     * Get the app settings associated with the given app.
     *
     * @returns the {@link AppSettings}
     */
    getAppSettings(): Promise<AppSettings>;
    /**
     * Get the allowlist entries for a the given app. This is a list of users that are allowed to access the app,
     * if the allowlist is enabled.
     *
     *
     * ```typescript
     * const allowlist = await client.getAllowlist();
     * ```
     *
     * @returns a list of {@link AllowlistEntry} objects.
     */
    getAllowlist(): Promise<AllowlistEntry[]>;
    /**
     * Add an allowlist entry for the given app, to give that user access.
     *
     * The allowlist must enabled for the app, otherwise this will fail.
     *
     *
     * ```typescript
     * const entry = await client.inviteToAllowlist({ type: 'email', value: 'batman@privy.io'});
     * ```
     * @param allowlistEntry The {@link AllowlistEntryInput} to add to the allowlist.
     * @returns the created {@link AllowlistEntry} object.
     */
    inviteToAllowlist(allowlistEntry: AllowlistEntryInput): Promise<AllowlistEntry>;
    /**
     * Remove an entry from the allowlist for a Privy app.
     *
     * The allowlist must enabled for the app, otherwise this will fail.
     *
     * ```typescript
     * await client.removeFromAllowlist();
     * ```
     *
     * @param allowlistEntry The {@link AllowlistEntryInput} to remove from the allowlist.
     * @returns the deleted {@link AllowlistEntry} object.
     */
    removeFromAllowlist(allowlistEntry: AllowlistEntryInput): Promise<AllowlistEntry>;
    /**
     * Verify the auth token format, signature, and claims.
     *
     * Example usage given e.g. a `NextApiRequest` request:
     * ```typescript
     * const header = request.headers.authorization;
     * const token = header.replace(/^Bearer /, '');
     * const verifiedClaims = await verifyAuthToken(token);
     * ```
     *
     * @param token The auth token (JWT).
     * @param verificationKeyOverride Overrides the default ES256 JWT verification key loaded from app settings.
     * @returns Object containing auth token claims.
     */
    verifyAuthToken(token: string, verificationKeyOverride?: string): Promise<AuthTokenClaims>;
    /**
     * Get the auth token verification key.
     *
     * Note that the verification key is pulled from app settings for the first time only and then
     * cached. On subsequent calls the cached verification key is returned.
     *
     * @returns String holding the verification key.
     */
    getVerificationKey(): Promise<string>;
    /**
     * Verifies a webhook request by checking the signature and asserting the timestamp is
     * within 5 minutes of the current time to prevent replay attacks.
     *
     * @param payload The raw JSON payload/body of the webhook request. This must be unaltered or signature verification will fail.
     * @param headers A JSON object containing the webhook's ID, timestamp, and signature sent in the headers of the webhook request. This input object must contain `id`, `timestamp`, and `signature` keys.
     * @param secret The webhook secret to use for verifying the webhook request.
     * @returns verified payload if the webhook signature is valid otherwise throws.
     */
    verifyWebhook(payload: Object, headers: WebhooksVerificationHeaderInput, secret: string): Promise<unknown>;
    /**
     * Get an access token for the test account for your app. Will throw an error if you have not enabled test credentials in the dashboard.
     * Will throw an error if allowed origins or base domain are enabled for the app.
     *
     * @param {Object} params - An optional object containing email or phoneNumber for the test account.
     * @param {string} params.email - The email of the test account.
     * @param {string} params.phoneNumber - The phone number of the test account.
     * @returns {
     *  token: string
     * }
     */
    getTestAccessToken(params?: {
        email?: string;
        phoneNumber?: string;
    }): Promise<{
        accessToken: string;
    }>;
    /**
     * Add customMetadata field to the user object.
     *
     * @param userId DID of the user to set custom metadata for
     * @param customMetadata the custom metadata to set for the user
     * @returns user object updated with custom metadata
     */
    setCustomMetadata<CustomMetadataInput extends Record<string, string | number | boolean>>(userId: string, customMetadata: CustomMetadataInput): Promise<User>;
    /**
     * Gets a user from the identity token. First, this verifies the token is valid and then parses
     * the payload into a `User` object. Note the user object may be incomplete due to identity token
     * size constraints
     *
     * ```typescript
     * const user = await client.getUser({idToken: cookieIdToken});
     * ```
     *
     * @param idToken the identity token set as a cookie on the users browser
     * @returns the user object with parsed from the ID token
     */
    getUserFromIdToken(idToken: string): Promise<User>;
}

export { AllowlistEntry, AppSettings, AuthTokenClaims, ImportUserInput, PrivyClient, User };
