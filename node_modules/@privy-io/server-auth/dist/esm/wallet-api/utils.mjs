import{Chacha20Poly1305 as e}from"@hpke/chacha20poly1305";import{CipherSuite as r,DhkemP256HkdfSha256 as t,HkdfSha256 as a}from"@hpke/core";import{p256 as o}from"@noble/curves/p256";import{sha256 as i}from"@noble/hashes/sha256";import n from"canonicalize";import{AUTHORIZATION_PRIVATE_KEY_PREFIX as d,WALLET_API_PRIVATE_KEY_PREFIX as p}from"../constants.mjs";import{PrivyClientError as s}from"../errors.mjs";import{getWalletApiRpcPath as y,getUserByWalletAddressPath as u}from"../paths.mjs";const l=e=>Buffer.from(n(e)),f=(e,r)=>{let t=o.sign(i(e),r).toDERRawBytes();return Buffer.from(t)},c=e=>{let r=e.replace(d,"").replace(p,""),t=Buffer.from(r,"base64"),a=t.indexOf(Buffer.from([4,32]));if(-1===a)throw new s("Invalid wallet authorization private key");let i=t.subarray(a+2,a+34);return o.utils.normPrivateKeyToScalar(i)},m=e=>{if(void 0!==e.idempotencyKey)return{"privy-idempotency-key":e.idempotencyKey}},w=async(e,r)=>{let t;if("walletId"in e)t=y(e.walletId);else{if(!("address"in e))throw new s("Invalid RPC payload. Must include `walletId`.");{console.warn("Warning: using deprecated input 'address' this will be removed in a a future version. Use 'walletId' instead.");let a=await k(r,e.address);if(!a)throw new s(`No wallet account found for address ${e.address}`);t=y(a)}}return t},h=({method:e,url:r,body:t,appId:a,idempotencyKeyHeader:o})=>{let i={version:1,method:e,url:r,body:t,headers:{"privy-app-id":a,...o}};return l(i)},b=({method:e,url:r,body:t,appId:a,idempotencyKeyHeader:o,authorizationPrivateKey:i})=>{if("bigint"!=typeof i)return;let n=h({method:e,url:r,body:t,appId:a,idempotencyKeyHeader:o});return f(n,i).toString("base64")},v=({method:e,body:r,url:t,appId:a,idempotencyKeyHeader:o,authorizationPrivateKey:i})=>{let n=b({method:e,body:r,url:t,appId:a,idempotencyKeyHeader:o,authorizationPrivateKey:i});if(n)return{"privy-authorization-signature":n}};async function K(){let e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),r=await crypto.subtle.exportKey("spki",e.publicKey),t=await crypto.subtle.exportKey("pkcs8",e.privateKey);return{publicKey:Buffer.from(r),privateKey:Buffer.from(t)}}async function I(o,i,n){let d=new r({kem:new t,kdf:new a,aead:new e}),p=await crypto.subtle.importKey("pkcs8",Uint8Array.from(atob(o),(e=>e.charCodeAt(0))).buffer,{name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"]),s=await d.createRecipientContext({recipientKey:p,enc:Uint8Array.from(atob(i),(e=>e.charCodeAt(0))).buffer});return(new TextDecoder).decode(await s.open(Uint8Array.from(atob(n),(e=>e.charCodeAt(0))).buffer))}async function k(e,r){let t=u(),a=(await e.post(t,{address:r})).data.linked_accounts.find((e=>"wallet"===e.type&&e.address===r));return a?.id}export{v as createAuthorizationSignatureHeader,K as createP256KeyPair,I as decryptHPKEMessage,m as extractIdempotencyKeyHeader,h as formatAuthorizationSignatureRequest,w as getRpcPathForRequest,k as getWalletIdFromAddress,c as normalizeP256PrivateKeyToScalar,l as serializePayloadToBuffer,b as signAuthorizationSignatureRequest,f as signWithP256};
